// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#include "messages.g.h"

struct _CameraLinuxPlatformSize {
  GObject parent_instance;

  double width;
  double height;
};

G_DEFINE_TYPE(CameraLinuxPlatformSize, camera_linux_platform_size, G_TYPE_OBJECT)

static void camera_linux_platform_size_dispose(GObject* object) {
  G_OBJECT_CLASS(camera_linux_platform_size_parent_class)->dispose(object);
}

static void camera_linux_platform_size_init(CameraLinuxPlatformSize* self) {
}

static void camera_linux_platform_size_class_init(CameraLinuxPlatformSizeClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_size_dispose;
}

CameraLinuxPlatformSize* camera_linux_platform_size_new(double width, double height) {
  CameraLinuxPlatformSize* self = CAMERA_LINUX_PLATFORM_SIZE(g_object_new(camera_linux_platform_size_get_type(), nullptr));
  self->width = width;
  self->height = height;
  return self;
}

double camera_linux_platform_size_get_width(CameraLinuxPlatformSize* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_SIZE(self), 0.0);
  return self->width;
}

double camera_linux_platform_size_get_height(CameraLinuxPlatformSize* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_SIZE(self), 0.0);
  return self->height;
}

static FlValue* camera_linux_platform_size_to_list(CameraLinuxPlatformSize* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->width));
  fl_value_append_take(values, fl_value_new_float(self->height));
  return values;
}

static CameraLinuxPlatformSize* camera_linux_platform_size_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double width = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double height = fl_value_get_float(value1);
  return camera_linux_platform_size_new(width, height);
}

struct _CameraLinuxPlatformCameraState {
  GObject parent_instance;

  CameraLinuxPlatformSize* preview_size;
  CameraLinuxPlatformExposureMode exposure_mode;
  CameraLinuxPlatformFocusMode focus_mode;
  gboolean exposure_point_supported;
  gboolean focus_point_supported;
};

G_DEFINE_TYPE(CameraLinuxPlatformCameraState, camera_linux_platform_camera_state, G_TYPE_OBJECT)

static void camera_linux_platform_camera_state_dispose(GObject* object) {
  CameraLinuxPlatformCameraState* self = CAMERA_LINUX_PLATFORM_CAMERA_STATE(object);
  g_clear_object(&self->preview_size);
  G_OBJECT_CLASS(camera_linux_platform_camera_state_parent_class)->dispose(object);
}

static void camera_linux_platform_camera_state_init(CameraLinuxPlatformCameraState* self) {
}

static void camera_linux_platform_camera_state_class_init(CameraLinuxPlatformCameraStateClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_camera_state_dispose;
}

CameraLinuxPlatformCameraState* camera_linux_platform_camera_state_new(CameraLinuxPlatformSize* preview_size, CameraLinuxPlatformExposureMode exposure_mode, CameraLinuxPlatformFocusMode focus_mode, gboolean exposure_point_supported, gboolean focus_point_supported) {
  CameraLinuxPlatformCameraState* self = CAMERA_LINUX_PLATFORM_CAMERA_STATE(g_object_new(camera_linux_platform_camera_state_get_type(), nullptr));
  self->preview_size = CAMERA_LINUX_PLATFORM_SIZE(g_object_ref(preview_size));
  self->exposure_mode = exposure_mode;
  self->focus_mode = focus_mode;
  self->exposure_point_supported = exposure_point_supported;
  self->focus_point_supported = focus_point_supported;
  return self;
}

CameraLinuxPlatformSize* camera_linux_platform_camera_state_get_preview_size(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), nullptr);
  return self->preview_size;
}

CameraLinuxPlatformExposureMode camera_linux_platform_camera_state_get_exposure_mode(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), static_cast<CameraLinuxPlatformExposureMode>(0));
  return self->exposure_mode;
}

CameraLinuxPlatformFocusMode camera_linux_platform_camera_state_get_focus_mode(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), static_cast<CameraLinuxPlatformFocusMode>(0));
  return self->focus_mode;
}

gboolean camera_linux_platform_camera_state_get_exposure_point_supported(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), FALSE);
  return self->exposure_point_supported;
}

gboolean camera_linux_platform_camera_state_get_focus_point_supported(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), FALSE);
  return self->focus_point_supported;
}

static FlValue* camera_linux_platform_camera_state_to_list(CameraLinuxPlatformCameraState* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_custom_object(135, G_OBJECT(self->preview_size)));
  fl_value_append_take(values, fl_value_new_custom(130, fl_value_new_int(self->exposure_mode), (GDestroyNotify)fl_value_unref));
  fl_value_append_take(values, fl_value_new_custom(132, fl_value_new_int(self->focus_mode), (GDestroyNotify)fl_value_unref));
  fl_value_append_take(values, fl_value_new_bool(self->exposure_point_supported));
  fl_value_append_take(values, fl_value_new_bool(self->focus_point_supported));
  return values;
}

static CameraLinuxPlatformCameraState* camera_linux_platform_camera_state_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  CameraLinuxPlatformSize* preview_size = CAMERA_LINUX_PLATFORM_SIZE(fl_value_get_custom_value_object(value0));
  FlValue* value1 = fl_value_get_list_value(values, 1);
  CameraLinuxPlatformExposureMode exposure_mode = static_cast<CameraLinuxPlatformExposureMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  FlValue* value2 = fl_value_get_list_value(values, 2);
  CameraLinuxPlatformFocusMode focus_mode = static_cast<CameraLinuxPlatformFocusMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value2)))));
  FlValue* value3 = fl_value_get_list_value(values, 3);
  gboolean exposure_point_supported = fl_value_get_bool(value3);
  FlValue* value4 = fl_value_get_list_value(values, 4);
  gboolean focus_point_supported = fl_value_get_bool(value4);
  return camera_linux_platform_camera_state_new(preview_size, exposure_mode, focus_mode, exposure_point_supported, focus_point_supported);
}

struct _CameraLinuxPlatformPoint {
  GObject parent_instance;

  double x;
  double y;
};

G_DEFINE_TYPE(CameraLinuxPlatformPoint, camera_linux_platform_point, G_TYPE_OBJECT)

static void camera_linux_platform_point_dispose(GObject* object) {
  G_OBJECT_CLASS(camera_linux_platform_point_parent_class)->dispose(object);
}

static void camera_linux_platform_point_init(CameraLinuxPlatformPoint* self) {
}

static void camera_linux_platform_point_class_init(CameraLinuxPlatformPointClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_point_dispose;
}

CameraLinuxPlatformPoint* camera_linux_platform_point_new(double x, double y) {
  CameraLinuxPlatformPoint* self = CAMERA_LINUX_PLATFORM_POINT(g_object_new(camera_linux_platform_point_get_type(), nullptr));
  self->x = x;
  self->y = y;
  return self;
}

double camera_linux_platform_point_get_x(CameraLinuxPlatformPoint* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_POINT(self), 0.0);
  return self->x;
}

double camera_linux_platform_point_get_y(CameraLinuxPlatformPoint* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_POINT(self), 0.0);
  return self->y;
}

static FlValue* camera_linux_platform_point_to_list(CameraLinuxPlatformPoint* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->x));
  fl_value_append_take(values, fl_value_new_float(self->y));
  return values;
}

static CameraLinuxPlatformPoint* camera_linux_platform_point_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double x = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double y = fl_value_get_float(value1);
  return camera_linux_platform_point_new(x, y);
}

struct _CameraLinuxMessageCodec {
  FlStandardMessageCodec parent_instance;

};

G_DEFINE_TYPE(CameraLinuxMessageCodec, camera_linux_message_codec, fl_standard_message_codec_get_type())

static gboolean camera_linux_message_codec_write_camera_linux_platform_device_orientation(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 129;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_exposure_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 130;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_flash_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 131;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_focus_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 132;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_image_format_group(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 133;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_resolution_preset(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 134;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_size(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformSize* value, GError** error) {
  uint8_t type = 135;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_size_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_camera_state(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformCameraState* value, GError** error) {
  uint8_t type = 136;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_camera_state_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_point(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformPoint* value, GError** error) {
  uint8_t type = 137;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_point_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_value(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  if (fl_value_get_type(value) == FL_VALUE_TYPE_CUSTOM) {
    switch (fl_value_get_custom_type(value)) {
      case 129:
        return camera_linux_message_codec_write_camera_linux_platform_device_orientation(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 130:
        return camera_linux_message_codec_write_camera_linux_platform_exposure_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 131:
        return camera_linux_message_codec_write_camera_linux_platform_flash_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 132:
        return camera_linux_message_codec_write_camera_linux_platform_focus_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 133:
        return camera_linux_message_codec_write_camera_linux_platform_image_format_group(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 134:
        return camera_linux_message_codec_write_camera_linux_platform_resolution_preset(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 135:
        return camera_linux_message_codec_write_camera_linux_platform_size(codec, buffer, CAMERA_LINUX_PLATFORM_SIZE(fl_value_get_custom_value_object(value)), error);
      case 136:
        return camera_linux_message_codec_write_camera_linux_platform_camera_state(codec, buffer, CAMERA_LINUX_PLATFORM_CAMERA_STATE(fl_value_get_custom_value_object(value)), error);
      case 137:
        return camera_linux_message_codec_write_camera_linux_platform_point(codec, buffer, CAMERA_LINUX_PLATFORM_POINT(fl_value_get_custom_value_object(value)), error);
    }
  }

  return FL_STANDARD_MESSAGE_CODEC_CLASS(camera_linux_message_codec_parent_class)->write_value(codec, buffer, value, error);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_device_orientation(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(129, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_exposure_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(130, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_flash_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(131, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_focus_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(132, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_image_format_group(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(133, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_resolution_preset(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(134, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_size(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformSize) value = camera_linux_platform_size_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(135, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_camera_state(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformCameraState) value = camera_linux_platform_camera_state_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(136, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_point(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformPoint) value = camera_linux_platform_point_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(137, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_value_of_type(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, int type, GError** error) {
  switch (type) {
    case 129:
      return camera_linux_message_codec_read_camera_linux_platform_device_orientation(codec, buffer, offset, error);
    case 130:
      return camera_linux_message_codec_read_camera_linux_platform_exposure_mode(codec, buffer, offset, error);
    case 131:
      return camera_linux_message_codec_read_camera_linux_platform_flash_mode(codec, buffer, offset, error);
    case 132:
      return camera_linux_message_codec_read_camera_linux_platform_focus_mode(codec, buffer, offset, error);
    case 133:
      return camera_linux_message_codec_read_camera_linux_platform_image_format_group(codec, buffer, offset, error);
    case 134:
      return camera_linux_message_codec_read_camera_linux_platform_resolution_preset(codec, buffer, offset, error);
    case 135:
      return camera_linux_message_codec_read_camera_linux_platform_size(codec, buffer, offset, error);
    case 136:
      return camera_linux_message_codec_read_camera_linux_platform_camera_state(codec, buffer, offset, error);
    case 137:
      return camera_linux_message_codec_read_camera_linux_platform_point(codec, buffer, offset, error);
    default:
      return FL_STANDARD_MESSAGE_CODEC_CLASS(camera_linux_message_codec_parent_class)->read_value_of_type(codec, buffer, offset, type, error);
  }
}

static void camera_linux_message_codec_init(CameraLinuxMessageCodec* self) {
}

static void camera_linux_message_codec_class_init(CameraLinuxMessageCodecClass* klass) {
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->write_value = camera_linux_message_codec_write_value;
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->read_value_of_type = camera_linux_message_codec_read_value_of_type;
}

static CameraLinuxMessageCodec* camera_linux_message_codec_new() {
  CameraLinuxMessageCodec* self = CAMERA_LINUX_MESSAGE_CODEC(g_object_new(camera_linux_message_codec_get_type(), nullptr));
  return self;
}

struct _CameraLinuxCameraApiResponseHandle {
  GObject parent_instance;

  FlBasicMessageChannel* channel;
  FlBasicMessageChannelResponseHandle* response_handle;
};

G_DEFINE_TYPE(CameraLinuxCameraApiResponseHandle, camera_linux_camera_api_response_handle, G_TYPE_OBJECT)

static void camera_linux_camera_api_response_handle_dispose(GObject* object) {
  CameraLinuxCameraApiResponseHandle* self = CAMERA_LINUX_CAMERA_API_RESPONSE_HANDLE(object);
  g_clear_object(&self->channel);
  g_clear_object(&self->response_handle);
  G_OBJECT_CLASS(camera_linux_camera_api_response_handle_parent_class)->dispose(object);
}

static void camera_linux_camera_api_response_handle_init(CameraLinuxCameraApiResponseHandle* self) {
}

static void camera_linux_camera_api_response_handle_class_init(CameraLinuxCameraApiResponseHandleClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_response_handle_dispose;
}

static CameraLinuxCameraApiResponseHandle* camera_linux_camera_api_response_handle_new(FlBasicMessageChannel* channel, FlBasicMessageChannelResponseHandle* response_handle) {
  CameraLinuxCameraApiResponseHandle* self = CAMERA_LINUX_CAMERA_API_RESPONSE_HANDLE(g_object_new(camera_linux_camera_api_response_handle_get_type(), nullptr));
  self->channel = FL_BASIC_MESSAGE_CHANNEL(g_object_ref(channel));
  self->response_handle = FL_BASIC_MESSAGE_CHANNEL_RESPONSE_HANDLE(g_object_ref(response_handle));
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetAvailableCamerasNamesResponse, camera_linux_camera_api_get_available_cameras_names_response, CAMERA_LINUX, CAMERA_API_GET_AVAILABLE_CAMERAS_NAMES_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetAvailableCamerasNamesResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetAvailableCamerasNamesResponse, camera_linux_camera_api_get_available_cameras_names_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_available_cameras_names_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetAvailableCamerasNamesResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_NAMES_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_available_cameras_names_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_available_cameras_names_response_init(CameraLinuxCameraApiGetAvailableCamerasNamesResponse* self) {
}

static void camera_linux_camera_api_get_available_cameras_names_response_class_init(CameraLinuxCameraApiGetAvailableCamerasNamesResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_available_cameras_names_response_dispose;
}

static CameraLinuxCameraApiGetAvailableCamerasNamesResponse* camera_linux_camera_api_get_available_cameras_names_response_new(FlValue* return_value) {
  CameraLinuxCameraApiGetAvailableCamerasNamesResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_NAMES_RESPONSE(g_object_new(camera_linux_camera_api_get_available_cameras_names_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_ref(return_value));
  return self;
}

static CameraLinuxCameraApiGetAvailableCamerasNamesResponse* camera_linux_camera_api_get_available_cameras_names_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetAvailableCamerasNamesResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_NAMES_RESPONSE(g_object_new(camera_linux_camera_api_get_available_cameras_names_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiCreateResponse, camera_linux_camera_api_create_response, CAMERA_LINUX, CAMERA_API_CREATE_RESPONSE, GObject)

struct _CameraLinuxCameraApiCreateResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiCreateResponse, camera_linux_camera_api_create_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_create_response_dispose(GObject* object) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_create_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_create_response_init(CameraLinuxCameraApiCreateResponse* self) {
}

static void camera_linux_camera_api_create_response_class_init(CameraLinuxCameraApiCreateResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_create_response_dispose;
}

static CameraLinuxCameraApiCreateResponse* camera_linux_camera_api_create_response_new(int64_t return_value) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(g_object_new(camera_linux_camera_api_create_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_int(return_value));
  return self;
}

static CameraLinuxCameraApiCreateResponse* camera_linux_camera_api_create_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(g_object_new(camera_linux_camera_api_create_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiInitializeResponse, camera_linux_camera_api_initialize_response, CAMERA_LINUX, CAMERA_API_INITIALIZE_RESPONSE, GObject)

struct _CameraLinuxCameraApiInitializeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiInitializeResponse, camera_linux_camera_api_initialize_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_initialize_response_dispose(GObject* object) {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_initialize_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_initialize_response_init(CameraLinuxCameraApiInitializeResponse* self) {
}

static void camera_linux_camera_api_initialize_response_class_init(CameraLinuxCameraApiInitializeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_initialize_response_dispose;
}

static CameraLinuxCameraApiInitializeResponse* camera_linux_camera_api_initialize_response_new() {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(g_object_new(camera_linux_camera_api_initialize_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiInitializeResponse* camera_linux_camera_api_initialize_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(g_object_new(camera_linux_camera_api_initialize_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetTextureIdResponse, camera_linux_camera_api_get_texture_id_response, CAMERA_LINUX, CAMERA_API_GET_TEXTURE_ID_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetTextureIdResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetTextureIdResponse, camera_linux_camera_api_get_texture_id_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_texture_id_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetTextureIdResponse* self = CAMERA_LINUX_CAMERA_API_GET_TEXTURE_ID_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_texture_id_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_texture_id_response_init(CameraLinuxCameraApiGetTextureIdResponse* self) {
}

static void camera_linux_camera_api_get_texture_id_response_class_init(CameraLinuxCameraApiGetTextureIdResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_texture_id_response_dispose;
}

static CameraLinuxCameraApiGetTextureIdResponse* camera_linux_camera_api_get_texture_id_response_new(int64_t* return_value) {
  CameraLinuxCameraApiGetTextureIdResponse* self = CAMERA_LINUX_CAMERA_API_GET_TEXTURE_ID_RESPONSE(g_object_new(camera_linux_camera_api_get_texture_id_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, return_value != nullptr ? fl_value_new_int(*return_value) : fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiGetTextureIdResponse* camera_linux_camera_api_get_texture_id_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetTextureIdResponse* self = CAMERA_LINUX_CAMERA_API_GET_TEXTURE_ID_RESPONSE(g_object_new(camera_linux_camera_api_get_texture_id_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiDisposeResponse, camera_linux_camera_api_dispose_response, CAMERA_LINUX, CAMERA_API_DISPOSE_RESPONSE, GObject)

struct _CameraLinuxCameraApiDisposeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiDisposeResponse, camera_linux_camera_api_dispose_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_dispose_response_dispose(GObject* object) {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_dispose_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_dispose_response_init(CameraLinuxCameraApiDisposeResponse* self) {
}

static void camera_linux_camera_api_dispose_response_class_init(CameraLinuxCameraApiDisposeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_dispose_response_dispose;
}

static CameraLinuxCameraApiDisposeResponse* camera_linux_camera_api_dispose_response_new() {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(g_object_new(camera_linux_camera_api_dispose_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiDisposeResponse* camera_linux_camera_api_dispose_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(g_object_new(camera_linux_camera_api_dispose_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiTakePictureResponse, camera_linux_camera_api_take_picture_response, CAMERA_LINUX, CAMERA_API_TAKE_PICTURE_RESPONSE, GObject)

struct _CameraLinuxCameraApiTakePictureResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiTakePictureResponse, camera_linux_camera_api_take_picture_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_take_picture_response_dispose(GObject* object) {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_take_picture_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_take_picture_response_init(CameraLinuxCameraApiTakePictureResponse* self) {
}

static void camera_linux_camera_api_take_picture_response_class_init(CameraLinuxCameraApiTakePictureResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_take_picture_response_dispose;
}

static CameraLinuxCameraApiTakePictureResponse* camera_linux_camera_api_take_picture_response_new() {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(g_object_new(camera_linux_camera_api_take_picture_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiTakePictureResponse* camera_linux_camera_api_take_picture_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(g_object_new(camera_linux_camera_api_take_picture_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStartVideoRecordingResponse, camera_linux_camera_api_start_video_recording_response, CAMERA_LINUX, CAMERA_API_START_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiStartVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStartVideoRecordingResponse, camera_linux_camera_api_start_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_start_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_start_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_start_video_recording_response_init(CameraLinuxCameraApiStartVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_start_video_recording_response_class_init(CameraLinuxCameraApiStartVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_start_video_recording_response_dispose;
}

static CameraLinuxCameraApiStartVideoRecordingResponse* camera_linux_camera_api_start_video_recording_response_new() {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_start_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiStartVideoRecordingResponse* camera_linux_camera_api_start_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_start_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStopVideoRecordingResponse, camera_linux_camera_api_stop_video_recording_response, CAMERA_LINUX, CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiStopVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStopVideoRecordingResponse, camera_linux_camera_api_stop_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_stop_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_stop_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_stop_video_recording_response_init(CameraLinuxCameraApiStopVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_stop_video_recording_response_class_init(CameraLinuxCameraApiStopVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_stop_video_recording_response_dispose;
}

static CameraLinuxCameraApiStopVideoRecordingResponse* camera_linux_camera_api_stop_video_recording_response_new(const gchar* return_value) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_stop_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(return_value));
  return self;
}

static CameraLinuxCameraApiStopVideoRecordingResponse* camera_linux_camera_api_stop_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_stop_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetExposureModeResponse, camera_linux_camera_api_set_exposure_mode_response, CAMERA_LINUX, CAMERA_API_SET_EXPOSURE_MODE_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetExposureModeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetExposureModeResponse, camera_linux_camera_api_set_exposure_mode_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_exposure_mode_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_exposure_mode_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_exposure_mode_response_init(CameraLinuxCameraApiSetExposureModeResponse* self) {
}

static void camera_linux_camera_api_set_exposure_mode_response_class_init(CameraLinuxCameraApiSetExposureModeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_exposure_mode_response_dispose;
}

static CameraLinuxCameraApiSetExposureModeResponse* camera_linux_camera_api_set_exposure_mode_response_new() {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetExposureModeResponse* camera_linux_camera_api_set_exposure_mode_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetFocusModeResponse, camera_linux_camera_api_set_focus_mode_response, CAMERA_LINUX, CAMERA_API_SET_FOCUS_MODE_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetFocusModeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetFocusModeResponse, camera_linux_camera_api_set_focus_mode_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_focus_mode_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_focus_mode_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_focus_mode_response_init(CameraLinuxCameraApiSetFocusModeResponse* self) {
}

static void camera_linux_camera_api_set_focus_mode_response_class_init(CameraLinuxCameraApiSetFocusModeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_focus_mode_response_dispose;
}

static CameraLinuxCameraApiSetFocusModeResponse* camera_linux_camera_api_set_focus_mode_response_new() {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetFocusModeResponse* camera_linux_camera_api_set_focus_mode_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetImageFormatGroupResponse, camera_linux_camera_api_set_image_format_group_response, CAMERA_LINUX, CAMERA_API_SET_IMAGE_FORMAT_GROUP_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetImageFormatGroupResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetImageFormatGroupResponse, camera_linux_camera_api_set_image_format_group_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_image_format_group_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetImageFormatGroupResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FORMAT_GROUP_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_image_format_group_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_image_format_group_response_init(CameraLinuxCameraApiSetImageFormatGroupResponse* self) {
}

static void camera_linux_camera_api_set_image_format_group_response_class_init(CameraLinuxCameraApiSetImageFormatGroupResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_image_format_group_response_dispose;
}

static CameraLinuxCameraApiSetImageFormatGroupResponse* camera_linux_camera_api_set_image_format_group_response_new() {
  CameraLinuxCameraApiSetImageFormatGroupResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FORMAT_GROUP_RESPONSE(g_object_new(camera_linux_camera_api_set_image_format_group_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetImageFormatGroupResponse* camera_linux_camera_api_set_image_format_group_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetImageFormatGroupResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FORMAT_GROUP_RESPONSE(g_object_new(camera_linux_camera_api_set_image_format_group_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

struct _CameraLinuxCameraApi {
  GObject parent_instance;

  const CameraLinuxCameraApiVTable* vtable;
  gpointer user_data;
  GDestroyNotify user_data_free_func;
};

G_DEFINE_TYPE(CameraLinuxCameraApi, camera_linux_camera_api, G_TYPE_OBJECT)

static void camera_linux_camera_api_dispose(GObject* object) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(object);
  if (self->user_data != nullptr) {
    self->user_data_free_func(self->user_data);
  }
  self->user_data = nullptr;
  G_OBJECT_CLASS(camera_linux_camera_api_parent_class)->dispose(object);
}

static void camera_linux_camera_api_init(CameraLinuxCameraApi* self) {
}

static void camera_linux_camera_api_class_init(CameraLinuxCameraApiClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_dispose;
}

static CameraLinuxCameraApi* camera_linux_camera_api_new(const CameraLinuxCameraApiVTable* vtable, gpointer user_data, GDestroyNotify user_data_free_func) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(g_object_new(camera_linux_camera_api_get_type(), nullptr));
  self->vtable = vtable;
  self->user_data = user_data;
  self->user_data_free_func = user_data_free_func;
  return self;
}

static void camera_linux_camera_api_get_available_cameras_names_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_available_cameras_names == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_available_cameras_names(handle, self->user_data);
}

static void camera_linux_camera_api_create_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->create == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  const gchar* camera_name = fl_value_get_string(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformResolutionPreset resolution_preset = static_cast<CameraLinuxPlatformResolutionPreset>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->create(camera_name, resolution_preset, handle, self->user_data);
}

static void camera_linux_camera_api_initialize_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->initialize == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformImageFormatGroup image_format = static_cast<CameraLinuxPlatformImageFormatGroup>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->initialize(camera_id, image_format, handle, self->user_data);
}

static void camera_linux_camera_api_get_texture_id_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_texture_id == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_texture_id(camera_id, handle, self->user_data);
}

static void camera_linux_camera_api_dispose_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->dispose == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->dispose(camera_id, handle, self->user_data);
}

static void camera_linux_camera_api_take_picture_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->take_picture == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  const gchar* path = fl_value_get_string(value1);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->take_picture(camera_id, path, handle, self->user_data);
}

static void camera_linux_camera_api_start_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->start_video_recording == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  gboolean enable_stream = fl_value_get_bool(value1);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->start_video_recording(camera_id, enable_stream, handle, self->user_data);
}

static void camera_linux_camera_api_stop_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->stop_video_recording == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->stop_video_recording(camera_id, handle, self->user_data);
}

static void camera_linux_camera_api_set_exposure_mode_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_exposure_mode == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformExposureMode mode = static_cast<CameraLinuxPlatformExposureMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_exposure_mode(camera_id, mode, handle, self->user_data);
}

static void camera_linux_camera_api_set_focus_mode_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_focus_mode == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformFocusMode mode = static_cast<CameraLinuxPlatformFocusMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_focus_mode(camera_id, mode, handle, self->user_data);
}

static void camera_linux_camera_api_set_image_format_group_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_image_format_group == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformImageFormatGroup image_format_group = static_cast<CameraLinuxPlatformImageFormatGroup>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_image_format_group(camera_id, image_format_group, handle, self->user_data);
}

void camera_linux_camera_api_set_method_handlers(FlBinaryMessenger* messenger, const gchar* suffix, const CameraLinuxCameraApiVTable* vtable, gpointer user_data, GDestroyNotify user_data_free_func) {
  g_autofree gchar* dot_suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  g_autoptr(CameraLinuxCameraApi) api_data = camera_linux_camera_api_new(vtable, user_data, user_data_free_func);

  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  g_autofree gchar* get_available_cameras_names_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getAvailableCamerasNames%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_available_cameras_names_channel = fl_basic_message_channel_new(messenger, get_available_cameras_names_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_available_cameras_names_channel, camera_linux_camera_api_get_available_cameras_names_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* create_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.create%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) create_channel = fl_basic_message_channel_new(messenger, create_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(create_channel, camera_linux_camera_api_create_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* initialize_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.initialize%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) initialize_channel = fl_basic_message_channel_new(messenger, initialize_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(initialize_channel, camera_linux_camera_api_initialize_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* get_texture_id_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getTextureId%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_texture_id_channel = fl_basic_message_channel_new(messenger, get_texture_id_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_texture_id_channel, camera_linux_camera_api_get_texture_id_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* dispose_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.dispose%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) dispose_channel = fl_basic_message_channel_new(messenger, dispose_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(dispose_channel, camera_linux_camera_api_dispose_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* take_picture_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.takePicture%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) take_picture_channel = fl_basic_message_channel_new(messenger, take_picture_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(take_picture_channel, camera_linux_camera_api_take_picture_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* start_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_video_recording_channel = fl_basic_message_channel_new(messenger, start_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_video_recording_channel, camera_linux_camera_api_start_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* stop_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_video_recording_channel = fl_basic_message_channel_new(messenger, stop_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_video_recording_channel, camera_linux_camera_api_stop_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_exposure_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_mode_channel = fl_basic_message_channel_new(messenger, set_exposure_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_mode_channel, camera_linux_camera_api_set_exposure_mode_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_focus_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_mode_channel = fl_basic_message_channel_new(messenger, set_focus_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_mode_channel, camera_linux_camera_api_set_focus_mode_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_image_format_group_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setImageFormatGroup%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_image_format_group_channel = fl_basic_message_channel_new(messenger, set_image_format_group_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_image_format_group_channel, camera_linux_camera_api_set_image_format_group_cb, g_object_ref(api_data), g_object_unref);
}

void camera_linux_camera_api_clear_method_handlers(FlBinaryMessenger* messenger, const gchar* suffix) {
  g_autofree gchar* dot_suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");

  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  g_autofree gchar* get_available_cameras_names_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getAvailableCamerasNames%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_available_cameras_names_channel = fl_basic_message_channel_new(messenger, get_available_cameras_names_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_available_cameras_names_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* create_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.create%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) create_channel = fl_basic_message_channel_new(messenger, create_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(create_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* initialize_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.initialize%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) initialize_channel = fl_basic_message_channel_new(messenger, initialize_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(initialize_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* get_texture_id_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getTextureId%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_texture_id_channel = fl_basic_message_channel_new(messenger, get_texture_id_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_texture_id_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* dispose_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.dispose%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) dispose_channel = fl_basic_message_channel_new(messenger, dispose_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(dispose_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* take_picture_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.takePicture%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) take_picture_channel = fl_basic_message_channel_new(messenger, take_picture_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(take_picture_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* start_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_video_recording_channel = fl_basic_message_channel_new(messenger, start_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* stop_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_video_recording_channel = fl_basic_message_channel_new(messenger, stop_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_exposure_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_mode_channel = fl_basic_message_channel_new(messenger, set_exposure_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_mode_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_focus_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_mode_channel = fl_basic_message_channel_new(messenger, set_focus_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_mode_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_image_format_group_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setImageFormatGroup%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_image_format_group_channel = fl_basic_message_channel_new(messenger, set_image_format_group_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_image_format_group_channel, nullptr, nullptr, nullptr);
}

void camera_linux_camera_api_respond_get_available_cameras_names(CameraLinuxCameraApiResponseHandle* response_handle, FlValue* return_value) {
  g_autoptr(CameraLinuxCameraApiGetAvailableCamerasNamesResponse) response = camera_linux_camera_api_get_available_cameras_names_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getAvailableCamerasNames", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_available_cameras_names(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetAvailableCamerasNamesResponse) response = camera_linux_camera_api_get_available_cameras_names_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getAvailableCamerasNames", error->message);
  }
}

void camera_linux_camera_api_respond_create(CameraLinuxCameraApiResponseHandle* response_handle, int64_t return_value) {
  g_autoptr(CameraLinuxCameraApiCreateResponse) response = camera_linux_camera_api_create_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "create", error->message);
  }
}

void camera_linux_camera_api_respond_error_create(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiCreateResponse) response = camera_linux_camera_api_create_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "create", error->message);
  }
}

void camera_linux_camera_api_respond_initialize(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiInitializeResponse) response = camera_linux_camera_api_initialize_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "initialize", error->message);
  }
}

void camera_linux_camera_api_respond_error_initialize(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiInitializeResponse) response = camera_linux_camera_api_initialize_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "initialize", error->message);
  }
}

void camera_linux_camera_api_respond_get_texture_id(CameraLinuxCameraApiResponseHandle* response_handle, int64_t* return_value) {
  g_autoptr(CameraLinuxCameraApiGetTextureIdResponse) response = camera_linux_camera_api_get_texture_id_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getTextureId", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_texture_id(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetTextureIdResponse) response = camera_linux_camera_api_get_texture_id_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getTextureId", error->message);
  }
}

void camera_linux_camera_api_respond_dispose(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiDisposeResponse) response = camera_linux_camera_api_dispose_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "dispose", error->message);
  }
}

void camera_linux_camera_api_respond_error_dispose(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiDisposeResponse) response = camera_linux_camera_api_dispose_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "dispose", error->message);
  }
}

void camera_linux_camera_api_respond_take_picture(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiTakePictureResponse) response = camera_linux_camera_api_take_picture_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "takePicture", error->message);
  }
}

void camera_linux_camera_api_respond_error_take_picture(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiTakePictureResponse) response = camera_linux_camera_api_take_picture_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "takePicture", error->message);
  }
}

void camera_linux_camera_api_respond_start_video_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiStartVideoRecordingResponse) response = camera_linux_camera_api_start_video_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_start_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStartVideoRecordingResponse) response = camera_linux_camera_api_start_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_stop_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* return_value) {
  g_autoptr(CameraLinuxCameraApiStopVideoRecordingResponse) response = camera_linux_camera_api_stop_video_recording_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_stop_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStopVideoRecordingResponse) response = camera_linux_camera_api_stop_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_set_exposure_mode(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetExposureModeResponse) response = camera_linux_camera_api_set_exposure_mode_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureMode", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_exposure_mode(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetExposureModeResponse) response = camera_linux_camera_api_set_exposure_mode_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureMode", error->message);
  }
}

void camera_linux_camera_api_respond_set_focus_mode(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetFocusModeResponse) response = camera_linux_camera_api_set_focus_mode_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusMode", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_focus_mode(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetFocusModeResponse) response = camera_linux_camera_api_set_focus_mode_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusMode", error->message);
  }
}

void camera_linux_camera_api_respond_set_image_format_group(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetImageFormatGroupResponse) response = camera_linux_camera_api_set_image_format_group_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setImageFormatGroup", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_image_format_group(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetImageFormatGroupResponse) response = camera_linux_camera_api_set_image_format_group_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setImageFormatGroup", error->message);
  }
}

struct _CameraLinuxCameraEventApi {
  GObject parent_instance;

  FlBinaryMessenger* messenger;
  gchar *suffix;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApi, camera_linux_camera_event_api, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_dispose(GObject* object) {
  CameraLinuxCameraEventApi* self = CAMERA_LINUX_CAMERA_EVENT_API(object);
  g_clear_object(&self->messenger);
  g_clear_pointer(&self->suffix, g_free);
  G_OBJECT_CLASS(camera_linux_camera_event_api_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_init(CameraLinuxCameraEventApi* self) {
}

static void camera_linux_camera_event_api_class_init(CameraLinuxCameraEventApiClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_dispose;
}

CameraLinuxCameraEventApi* camera_linux_camera_event_api_new(FlBinaryMessenger* messenger, const gchar* suffix) {
  CameraLinuxCameraEventApi* self = CAMERA_LINUX_CAMERA_EVENT_API(g_object_new(camera_linux_camera_event_api_get_type(), nullptr));
  self->messenger = FL_BINARY_MESSENGER(g_object_ref(messenger));
  self->suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  return self;
}

struct _CameraLinuxCameraEventApiInitializedResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApiInitializedResponse, camera_linux_camera_event_api_initialized_response, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_initialized_response_dispose(GObject* object) {
  CameraLinuxCameraEventApiInitializedResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_INITIALIZED_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_event_api_initialized_response_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_initialized_response_init(CameraLinuxCameraEventApiInitializedResponse* self) {
}

static void camera_linux_camera_event_api_initialized_response_class_init(CameraLinuxCameraEventApiInitializedResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_initialized_response_dispose;
}

static CameraLinuxCameraEventApiInitializedResponse* camera_linux_camera_event_api_initialized_response_new(FlValue* response) {
  CameraLinuxCameraEventApiInitializedResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_INITIALIZED_RESPONSE(g_object_new(camera_linux_camera_event_api_initialized_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_event_api_initialized_response_is_error(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_event_api_initialized_response_get_error_code(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_event_api_initialized_response_get_error_message(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_event_api_initialized_response_get_error_details(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_event_api_initialized_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_event_api_initialized(CameraLinuxCameraEventApi* self, CameraLinuxPlatformCameraState* initial_state, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_custom_object(136, G_OBJECT(initial_state)));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraEventApi.initialized%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_event_api_initialized_cb, task);
}

CameraLinuxCameraEventApiInitializedResponse* camera_linux_camera_event_api_initialized_finish(CameraLinuxCameraEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_event_api_initialized_response_new(response);
}

struct _CameraLinuxCameraEventApiTextureIdResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApiTextureIdResponse, camera_linux_camera_event_api_texture_id_response, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_texture_id_response_dispose(GObject* object) {
  CameraLinuxCameraEventApiTextureIdResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_event_api_texture_id_response_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_texture_id_response_init(CameraLinuxCameraEventApiTextureIdResponse* self) {
}

static void camera_linux_camera_event_api_texture_id_response_class_init(CameraLinuxCameraEventApiTextureIdResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_texture_id_response_dispose;
}

static CameraLinuxCameraEventApiTextureIdResponse* camera_linux_camera_event_api_texture_id_response_new(FlValue* response) {
  CameraLinuxCameraEventApiTextureIdResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(g_object_new(camera_linux_camera_event_api_texture_id_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_event_api_texture_id_response_is_error(CameraLinuxCameraEventApiTextureIdResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_event_api_texture_id_response_get_error_code(CameraLinuxCameraEventApiTextureIdResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_texture_id_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_event_api_texture_id_response_get_error_message(CameraLinuxCameraEventApiTextureIdResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_texture_id_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_event_api_texture_id_response_get_error_details(CameraLinuxCameraEventApiTextureIdResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_TEXTURE_ID_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_texture_id_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_event_api_texture_id_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_event_api_texture_id(CameraLinuxCameraEventApi* self, int64_t texture_id, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_int(texture_id));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraEventApi.textureId%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_event_api_texture_id_cb, task);
}

CameraLinuxCameraEventApiTextureIdResponse* camera_linux_camera_event_api_texture_id_finish(CameraLinuxCameraEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_event_api_texture_id_response_new(response);
}

struct _CameraLinuxCameraEventApiErrorResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApiErrorResponse, camera_linux_camera_event_api_error_response, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_error_response_dispose(GObject* object) {
  CameraLinuxCameraEventApiErrorResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_ERROR_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_event_api_error_response_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_error_response_init(CameraLinuxCameraEventApiErrorResponse* self) {
}

static void camera_linux_camera_event_api_error_response_class_init(CameraLinuxCameraEventApiErrorResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_error_response_dispose;
}

static CameraLinuxCameraEventApiErrorResponse* camera_linux_camera_event_api_error_response_new(FlValue* response) {
  CameraLinuxCameraEventApiErrorResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_ERROR_RESPONSE(g_object_new(camera_linux_camera_event_api_error_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_event_api_error_response_is_error(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_event_api_error_response_get_error_code(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_event_api_error_response_get_error_message(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_event_api_error_response_get_error_details(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_event_api_error_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_event_api_error(CameraLinuxCameraEventApi* self, const gchar* message, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_string(message));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraEventApi.error%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_event_api_error_cb, task);
}

CameraLinuxCameraEventApiErrorResponse* camera_linux_camera_event_api_error_finish(CameraLinuxCameraEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_event_api_error_response_new(response);
}
