// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#include "messages.g.h"

struct _CameraLinuxPlatformSize {
  GObject parent_instance;

  double width;
  double height;
};

G_DEFINE_TYPE(CameraLinuxPlatformSize, camera_linux_platform_size, G_TYPE_OBJECT)

static void camera_linux_platform_size_dispose(GObject* object) {
  G_OBJECT_CLASS(camera_linux_platform_size_parent_class)->dispose(object);
}

static void camera_linux_platform_size_init(CameraLinuxPlatformSize* self) {
}

static void camera_linux_platform_size_class_init(CameraLinuxPlatformSizeClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_size_dispose;
}

CameraLinuxPlatformSize* camera_linux_platform_size_new(double width, double height) {
  CameraLinuxPlatformSize* self = CAMERA_LINUX_PLATFORM_SIZE(g_object_new(camera_linux_platform_size_get_type(), nullptr));
  self->width = width;
  self->height = height;
  return self;
}

double camera_linux_platform_size_get_width(CameraLinuxPlatformSize* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_SIZE(self), 0.0);
  return self->width;
}

double camera_linux_platform_size_get_height(CameraLinuxPlatformSize* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_SIZE(self), 0.0);
  return self->height;
}

static FlValue* camera_linux_platform_size_to_list(CameraLinuxPlatformSize* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->width));
  fl_value_append_take(values, fl_value_new_float(self->height));
  return values;
}

static CameraLinuxPlatformSize* camera_linux_platform_size_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double width = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double height = fl_value_get_float(value1);
  return camera_linux_platform_size_new(width, height);
}

struct _CameraLinuxPlatformCameraDescription {
  GObject parent_instance;

  gchar* name;
  CameraLinuxPlatformCameraLensDirection lens_direction;
};

G_DEFINE_TYPE(CameraLinuxPlatformCameraDescription, camera_linux_platform_camera_description, G_TYPE_OBJECT)

static void camera_linux_platform_camera_description_dispose(GObject* object) {
  CameraLinuxPlatformCameraDescription* self = CAMERA_LINUX_PLATFORM_CAMERA_DESCRIPTION(object);
  g_clear_pointer(&self->name, g_free);
  G_OBJECT_CLASS(camera_linux_platform_camera_description_parent_class)->dispose(object);
}

static void camera_linux_platform_camera_description_init(CameraLinuxPlatformCameraDescription* self) {
}

static void camera_linux_platform_camera_description_class_init(CameraLinuxPlatformCameraDescriptionClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_camera_description_dispose;
}

CameraLinuxPlatformCameraDescription* camera_linux_platform_camera_description_new(const gchar* name, CameraLinuxPlatformCameraLensDirection lens_direction) {
  CameraLinuxPlatformCameraDescription* self = CAMERA_LINUX_PLATFORM_CAMERA_DESCRIPTION(g_object_new(camera_linux_platform_camera_description_get_type(), nullptr));
  self->name = g_strdup(name);
  self->lens_direction = lens_direction;
  return self;
}

const gchar* camera_linux_platform_camera_description_get_name(CameraLinuxPlatformCameraDescription* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_DESCRIPTION(self), nullptr);
  return self->name;
}

CameraLinuxPlatformCameraLensDirection camera_linux_platform_camera_description_get_lens_direction(CameraLinuxPlatformCameraDescription* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_DESCRIPTION(self), static_cast<CameraLinuxPlatformCameraLensDirection>(0));
  return self->lens_direction;
}

static FlValue* camera_linux_platform_camera_description_to_list(CameraLinuxPlatformCameraDescription* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_string(self->name));
  fl_value_append_take(values, fl_value_new_custom(129, fl_value_new_int(self->lens_direction), (GDestroyNotify)fl_value_unref));
  return values;
}

static CameraLinuxPlatformCameraDescription* camera_linux_platform_camera_description_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  const gchar* name = fl_value_get_string(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  CameraLinuxPlatformCameraLensDirection lens_direction = static_cast<CameraLinuxPlatformCameraLensDirection>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  return camera_linux_platform_camera_description_new(name, lens_direction);
}

struct _CameraLinuxPlatformCameraState {
  GObject parent_instance;

  CameraLinuxPlatformSize* preview_size;
  CameraLinuxPlatformExposureMode exposure_mode;
  CameraLinuxPlatformFocusMode focus_mode;
  gboolean exposure_point_supported;
  gboolean focus_point_supported;
};

G_DEFINE_TYPE(CameraLinuxPlatformCameraState, camera_linux_platform_camera_state, G_TYPE_OBJECT)

static void camera_linux_platform_camera_state_dispose(GObject* object) {
  CameraLinuxPlatformCameraState* self = CAMERA_LINUX_PLATFORM_CAMERA_STATE(object);
  g_clear_object(&self->preview_size);
  G_OBJECT_CLASS(camera_linux_platform_camera_state_parent_class)->dispose(object);
}

static void camera_linux_platform_camera_state_init(CameraLinuxPlatformCameraState* self) {
}

static void camera_linux_platform_camera_state_class_init(CameraLinuxPlatformCameraStateClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_camera_state_dispose;
}

CameraLinuxPlatformCameraState* camera_linux_platform_camera_state_new(CameraLinuxPlatformSize* preview_size, CameraLinuxPlatformExposureMode exposure_mode, CameraLinuxPlatformFocusMode focus_mode, gboolean exposure_point_supported, gboolean focus_point_supported) {
  CameraLinuxPlatformCameraState* self = CAMERA_LINUX_PLATFORM_CAMERA_STATE(g_object_new(camera_linux_platform_camera_state_get_type(), nullptr));
  self->preview_size = CAMERA_LINUX_PLATFORM_SIZE(g_object_ref(preview_size));
  self->exposure_mode = exposure_mode;
  self->focus_mode = focus_mode;
  self->exposure_point_supported = exposure_point_supported;
  self->focus_point_supported = focus_point_supported;
  return self;
}

CameraLinuxPlatformSize* camera_linux_platform_camera_state_get_preview_size(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), nullptr);
  return self->preview_size;
}

CameraLinuxPlatformExposureMode camera_linux_platform_camera_state_get_exposure_mode(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), static_cast<CameraLinuxPlatformExposureMode>(0));
  return self->exposure_mode;
}

CameraLinuxPlatformFocusMode camera_linux_platform_camera_state_get_focus_mode(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), static_cast<CameraLinuxPlatformFocusMode>(0));
  return self->focus_mode;
}

gboolean camera_linux_platform_camera_state_get_exposure_point_supported(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), FALSE);
  return self->exposure_point_supported;
}

gboolean camera_linux_platform_camera_state_get_focus_point_supported(CameraLinuxPlatformCameraState* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_CAMERA_STATE(self), FALSE);
  return self->focus_point_supported;
}

static FlValue* camera_linux_platform_camera_state_to_list(CameraLinuxPlatformCameraState* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_custom_object(137, G_OBJECT(self->preview_size)));
  fl_value_append_take(values, fl_value_new_custom(131, fl_value_new_int(self->exposure_mode), (GDestroyNotify)fl_value_unref));
  fl_value_append_take(values, fl_value_new_custom(133, fl_value_new_int(self->focus_mode), (GDestroyNotify)fl_value_unref));
  fl_value_append_take(values, fl_value_new_bool(self->exposure_point_supported));
  fl_value_append_take(values, fl_value_new_bool(self->focus_point_supported));
  return values;
}

static CameraLinuxPlatformCameraState* camera_linux_platform_camera_state_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  CameraLinuxPlatformSize* preview_size = CAMERA_LINUX_PLATFORM_SIZE(fl_value_get_custom_value_object(value0));
  FlValue* value1 = fl_value_get_list_value(values, 1);
  CameraLinuxPlatformExposureMode exposure_mode = static_cast<CameraLinuxPlatformExposureMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  FlValue* value2 = fl_value_get_list_value(values, 2);
  CameraLinuxPlatformFocusMode focus_mode = static_cast<CameraLinuxPlatformFocusMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value2)))));
  FlValue* value3 = fl_value_get_list_value(values, 3);
  gboolean exposure_point_supported = fl_value_get_bool(value3);
  FlValue* value4 = fl_value_get_list_value(values, 4);
  gboolean focus_point_supported = fl_value_get_bool(value4);
  return camera_linux_platform_camera_state_new(preview_size, exposure_mode, focus_mode, exposure_point_supported, focus_point_supported);
}

struct _CameraLinuxPlatformMediaSettings {
  GObject parent_instance;

  CameraLinuxPlatformResolutionPreset resolution_preset;
  int64_t* frames_per_second;
  int64_t* video_bitrate;
  int64_t* audio_bitrate;
  gboolean enable_audio;
};

G_DEFINE_TYPE(CameraLinuxPlatformMediaSettings, camera_linux_platform_media_settings, G_TYPE_OBJECT)

static void camera_linux_platform_media_settings_dispose(GObject* object) {
  CameraLinuxPlatformMediaSettings* self = CAMERA_LINUX_PLATFORM_MEDIA_SETTINGS(object);
  g_clear_pointer(&self->frames_per_second, g_free);
  g_clear_pointer(&self->video_bitrate, g_free);
  g_clear_pointer(&self->audio_bitrate, g_free);
  G_OBJECT_CLASS(camera_linux_platform_media_settings_parent_class)->dispose(object);
}

static void camera_linux_platform_media_settings_init(CameraLinuxPlatformMediaSettings* self) {
}

static void camera_linux_platform_media_settings_class_init(CameraLinuxPlatformMediaSettingsClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_media_settings_dispose;
}

CameraLinuxPlatformMediaSettings* camera_linux_platform_media_settings_new(CameraLinuxPlatformResolutionPreset resolution_preset, int64_t* frames_per_second, int64_t* video_bitrate, int64_t* audio_bitrate, gboolean enable_audio) {
  CameraLinuxPlatformMediaSettings* self = CAMERA_LINUX_PLATFORM_MEDIA_SETTINGS(g_object_new(camera_linux_platform_media_settings_get_type(), nullptr));
  self->resolution_preset = resolution_preset;
  if (frames_per_second != nullptr) {
    self->frames_per_second = static_cast<int64_t*>(malloc(sizeof(int64_t)));
    *self->frames_per_second = *frames_per_second;
  }
  else {
    self->frames_per_second = nullptr;
  }
  if (video_bitrate != nullptr) {
    self->video_bitrate = static_cast<int64_t*>(malloc(sizeof(int64_t)));
    *self->video_bitrate = *video_bitrate;
  }
  else {
    self->video_bitrate = nullptr;
  }
  if (audio_bitrate != nullptr) {
    self->audio_bitrate = static_cast<int64_t*>(malloc(sizeof(int64_t)));
    *self->audio_bitrate = *audio_bitrate;
  }
  else {
    self->audio_bitrate = nullptr;
  }
  self->enable_audio = enable_audio;
  return self;
}

CameraLinuxPlatformResolutionPreset camera_linux_platform_media_settings_get_resolution_preset(CameraLinuxPlatformMediaSettings* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_MEDIA_SETTINGS(self), static_cast<CameraLinuxPlatformResolutionPreset>(0));
  return self->resolution_preset;
}

int64_t* camera_linux_platform_media_settings_get_frames_per_second(CameraLinuxPlatformMediaSettings* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_MEDIA_SETTINGS(self), nullptr);
  return self->frames_per_second;
}

int64_t* camera_linux_platform_media_settings_get_video_bitrate(CameraLinuxPlatformMediaSettings* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_MEDIA_SETTINGS(self), nullptr);
  return self->video_bitrate;
}

int64_t* camera_linux_platform_media_settings_get_audio_bitrate(CameraLinuxPlatformMediaSettings* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_MEDIA_SETTINGS(self), nullptr);
  return self->audio_bitrate;
}

gboolean camera_linux_platform_media_settings_get_enable_audio(CameraLinuxPlatformMediaSettings* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_MEDIA_SETTINGS(self), FALSE);
  return self->enable_audio;
}

static FlValue* camera_linux_platform_media_settings_to_list(CameraLinuxPlatformMediaSettings* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_custom(136, fl_value_new_int(self->resolution_preset), (GDestroyNotify)fl_value_unref));
  fl_value_append_take(values, self->frames_per_second != nullptr ? fl_value_new_int(*self->frames_per_second) : fl_value_new_null());
  fl_value_append_take(values, self->video_bitrate != nullptr ? fl_value_new_int(*self->video_bitrate) : fl_value_new_null());
  fl_value_append_take(values, self->audio_bitrate != nullptr ? fl_value_new_int(*self->audio_bitrate) : fl_value_new_null());
  fl_value_append_take(values, fl_value_new_bool(self->enable_audio));
  return values;
}

static CameraLinuxPlatformMediaSettings* camera_linux_platform_media_settings_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  CameraLinuxPlatformResolutionPreset resolution_preset = static_cast<CameraLinuxPlatformResolutionPreset>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  FlValue* value1 = fl_value_get_list_value(values, 1);
  int64_t* frames_per_second = nullptr;
  int64_t frames_per_second_value;
  if (fl_value_get_type(value1) != FL_VALUE_TYPE_NULL) {
    frames_per_second_value = fl_value_get_int(value1);
    frames_per_second = &frames_per_second_value;
  }
  FlValue* value2 = fl_value_get_list_value(values, 2);
  int64_t* video_bitrate = nullptr;
  int64_t video_bitrate_value;
  if (fl_value_get_type(value2) != FL_VALUE_TYPE_NULL) {
    video_bitrate_value = fl_value_get_int(value2);
    video_bitrate = &video_bitrate_value;
  }
  FlValue* value3 = fl_value_get_list_value(values, 3);
  int64_t* audio_bitrate = nullptr;
  int64_t audio_bitrate_value;
  if (fl_value_get_type(value3) != FL_VALUE_TYPE_NULL) {
    audio_bitrate_value = fl_value_get_int(value3);
    audio_bitrate = &audio_bitrate_value;
  }
  FlValue* value4 = fl_value_get_list_value(values, 4);
  gboolean enable_audio = fl_value_get_bool(value4);
  return camera_linux_platform_media_settings_new(resolution_preset, frames_per_second, video_bitrate, audio_bitrate, enable_audio);
}

struct _CameraLinuxPlatformPoint {
  GObject parent_instance;

  double x;
  double y;
};

G_DEFINE_TYPE(CameraLinuxPlatformPoint, camera_linux_platform_point, G_TYPE_OBJECT)

static void camera_linux_platform_point_dispose(GObject* object) {
  G_OBJECT_CLASS(camera_linux_platform_point_parent_class)->dispose(object);
}

static void camera_linux_platform_point_init(CameraLinuxPlatformPoint* self) {
}

static void camera_linux_platform_point_class_init(CameraLinuxPlatformPointClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_platform_point_dispose;
}

CameraLinuxPlatformPoint* camera_linux_platform_point_new(double x, double y) {
  CameraLinuxPlatformPoint* self = CAMERA_LINUX_PLATFORM_POINT(g_object_new(camera_linux_platform_point_get_type(), nullptr));
  self->x = x;
  self->y = y;
  return self;
}

double camera_linux_platform_point_get_x(CameraLinuxPlatformPoint* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_POINT(self), 0.0);
  return self->x;
}

double camera_linux_platform_point_get_y(CameraLinuxPlatformPoint* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_PLATFORM_POINT(self), 0.0);
  return self->y;
}

static FlValue* camera_linux_platform_point_to_list(CameraLinuxPlatformPoint* self) {
  FlValue* values = fl_value_new_list();
  fl_value_append_take(values, fl_value_new_float(self->x));
  fl_value_append_take(values, fl_value_new_float(self->y));
  return values;
}

static CameraLinuxPlatformPoint* camera_linux_platform_point_new_from_list(FlValue* values) {
  FlValue* value0 = fl_value_get_list_value(values, 0);
  double x = fl_value_get_float(value0);
  FlValue* value1 = fl_value_get_list_value(values, 1);
  double y = fl_value_get_float(value1);
  return camera_linux_platform_point_new(x, y);
}

struct _CameraLinuxMessageCodec {
  FlStandardMessageCodec parent_instance;

};

G_DEFINE_TYPE(CameraLinuxMessageCodec, camera_linux_message_codec, fl_standard_message_codec_get_type())

static gboolean camera_linux_message_codec_write_camera_linux_platform_camera_lens_direction(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 129;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_device_orientation(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 130;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_exposure_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 131;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_flash_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 132;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_focus_mode(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 133;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_image_file_format(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 134;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_image_format_group(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 135;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_resolution_preset(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  uint8_t type = 136;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  return fl_standard_message_codec_write_value(codec, buffer, value, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_size(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformSize* value, GError** error) {
  uint8_t type = 137;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_size_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_camera_description(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformCameraDescription* value, GError** error) {
  uint8_t type = 138;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_camera_description_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_camera_state(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformCameraState* value, GError** error) {
  uint8_t type = 139;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_camera_state_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_media_settings(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformMediaSettings* value, GError** error) {
  uint8_t type = 140;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_media_settings_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_camera_linux_platform_point(FlStandardMessageCodec* codec, GByteArray* buffer, CameraLinuxPlatformPoint* value, GError** error) {
  uint8_t type = 141;
  g_byte_array_append(buffer, &type, sizeof(uint8_t));
  g_autoptr(FlValue) values = camera_linux_platform_point_to_list(value);
  return fl_standard_message_codec_write_value(codec, buffer, values, error);
}

static gboolean camera_linux_message_codec_write_value(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  if (fl_value_get_type(value) == FL_VALUE_TYPE_CUSTOM) {
    switch (fl_value_get_custom_type(value)) {
      case 129:
        return camera_linux_message_codec_write_camera_linux_platform_camera_lens_direction(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 130:
        return camera_linux_message_codec_write_camera_linux_platform_device_orientation(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 131:
        return camera_linux_message_codec_write_camera_linux_platform_exposure_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 132:
        return camera_linux_message_codec_write_camera_linux_platform_flash_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 133:
        return camera_linux_message_codec_write_camera_linux_platform_focus_mode(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 134:
        return camera_linux_message_codec_write_camera_linux_platform_image_file_format(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 135:
        return camera_linux_message_codec_write_camera_linux_platform_image_format_group(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 136:
        return camera_linux_message_codec_write_camera_linux_platform_resolution_preset(codec, buffer, reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value))), error);
      case 137:
        return camera_linux_message_codec_write_camera_linux_platform_size(codec, buffer, CAMERA_LINUX_PLATFORM_SIZE(fl_value_get_custom_value_object(value)), error);
      case 138:
        return camera_linux_message_codec_write_camera_linux_platform_camera_description(codec, buffer, CAMERA_LINUX_PLATFORM_CAMERA_DESCRIPTION(fl_value_get_custom_value_object(value)), error);
      case 139:
        return camera_linux_message_codec_write_camera_linux_platform_camera_state(codec, buffer, CAMERA_LINUX_PLATFORM_CAMERA_STATE(fl_value_get_custom_value_object(value)), error);
      case 140:
        return camera_linux_message_codec_write_camera_linux_platform_media_settings(codec, buffer, CAMERA_LINUX_PLATFORM_MEDIA_SETTINGS(fl_value_get_custom_value_object(value)), error);
      case 141:
        return camera_linux_message_codec_write_camera_linux_platform_point(codec, buffer, CAMERA_LINUX_PLATFORM_POINT(fl_value_get_custom_value_object(value)), error);
    }
  }

  return FL_STANDARD_MESSAGE_CODEC_CLASS(camera_linux_message_codec_parent_class)->write_value(codec, buffer, value, error);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_camera_lens_direction(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(129, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_device_orientation(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(130, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_exposure_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(131, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_flash_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(132, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_focus_mode(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(133, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_image_file_format(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(134, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_image_format_group(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(135, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_resolution_preset(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  return fl_value_new_custom(136, fl_standard_message_codec_read_value(codec, buffer, offset, error), (GDestroyNotify)fl_value_unref);
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_size(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformSize) value = camera_linux_platform_size_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(137, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_camera_description(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformCameraDescription) value = camera_linux_platform_camera_description_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(138, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_camera_state(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformCameraState) value = camera_linux_platform_camera_state_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(139, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_media_settings(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformMediaSettings) value = camera_linux_platform_media_settings_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(140, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_camera_linux_platform_point(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, GError** error) {
  g_autoptr(FlValue) values = fl_standard_message_codec_read_value(codec, buffer, offset, error);
  if (values == nullptr) {
    return nullptr;
  }

  g_autoptr(CameraLinuxPlatformPoint) value = camera_linux_platform_point_new_from_list(values);
  if (value == nullptr) {
    g_set_error(error, FL_MESSAGE_CODEC_ERROR, FL_MESSAGE_CODEC_ERROR_FAILED, "Invalid data received for MessageData");
    return nullptr;
  }

  return fl_value_new_custom_object(141, G_OBJECT(value));
}

static FlValue* camera_linux_message_codec_read_value_of_type(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, int type, GError** error) {
  switch (type) {
    case 129:
      return camera_linux_message_codec_read_camera_linux_platform_camera_lens_direction(codec, buffer, offset, error);
    case 130:
      return camera_linux_message_codec_read_camera_linux_platform_device_orientation(codec, buffer, offset, error);
    case 131:
      return camera_linux_message_codec_read_camera_linux_platform_exposure_mode(codec, buffer, offset, error);
    case 132:
      return camera_linux_message_codec_read_camera_linux_platform_flash_mode(codec, buffer, offset, error);
    case 133:
      return camera_linux_message_codec_read_camera_linux_platform_focus_mode(codec, buffer, offset, error);
    case 134:
      return camera_linux_message_codec_read_camera_linux_platform_image_file_format(codec, buffer, offset, error);
    case 135:
      return camera_linux_message_codec_read_camera_linux_platform_image_format_group(codec, buffer, offset, error);
    case 136:
      return camera_linux_message_codec_read_camera_linux_platform_resolution_preset(codec, buffer, offset, error);
    case 137:
      return camera_linux_message_codec_read_camera_linux_platform_size(codec, buffer, offset, error);
    case 138:
      return camera_linux_message_codec_read_camera_linux_platform_camera_description(codec, buffer, offset, error);
    case 139:
      return camera_linux_message_codec_read_camera_linux_platform_camera_state(codec, buffer, offset, error);
    case 140:
      return camera_linux_message_codec_read_camera_linux_platform_media_settings(codec, buffer, offset, error);
    case 141:
      return camera_linux_message_codec_read_camera_linux_platform_point(codec, buffer, offset, error);
    default:
      return FL_STANDARD_MESSAGE_CODEC_CLASS(camera_linux_message_codec_parent_class)->read_value_of_type(codec, buffer, offset, type, error);
  }
}

static void camera_linux_message_codec_init(CameraLinuxMessageCodec* self) {
}

static void camera_linux_message_codec_class_init(CameraLinuxMessageCodecClass* klass) {
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->write_value = camera_linux_message_codec_write_value;
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->read_value_of_type = camera_linux_message_codec_read_value_of_type;
}

static CameraLinuxMessageCodec* camera_linux_message_codec_new() {
  CameraLinuxMessageCodec* self = CAMERA_LINUX_MESSAGE_CODEC(g_object_new(camera_linux_message_codec_get_type(), nullptr));
  return self;
}

struct _CameraLinuxCameraApiResponseHandle {
  GObject parent_instance;

  FlBasicMessageChannel* channel;
  FlBasicMessageChannelResponseHandle* response_handle;
};

G_DEFINE_TYPE(CameraLinuxCameraApiResponseHandle, camera_linux_camera_api_response_handle, G_TYPE_OBJECT)

static void camera_linux_camera_api_response_handle_dispose(GObject* object) {
  CameraLinuxCameraApiResponseHandle* self = CAMERA_LINUX_CAMERA_API_RESPONSE_HANDLE(object);
  g_clear_object(&self->channel);
  g_clear_object(&self->response_handle);
  G_OBJECT_CLASS(camera_linux_camera_api_response_handle_parent_class)->dispose(object);
}

static void camera_linux_camera_api_response_handle_init(CameraLinuxCameraApiResponseHandle* self) {
}

static void camera_linux_camera_api_response_handle_class_init(CameraLinuxCameraApiResponseHandleClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_response_handle_dispose;
}

static CameraLinuxCameraApiResponseHandle* camera_linux_camera_api_response_handle_new(FlBasicMessageChannel* channel, FlBasicMessageChannelResponseHandle* response_handle) {
  CameraLinuxCameraApiResponseHandle* self = CAMERA_LINUX_CAMERA_API_RESPONSE_HANDLE(g_object_new(camera_linux_camera_api_response_handle_get_type(), nullptr));
  self->channel = FL_BASIC_MESSAGE_CHANNEL(g_object_ref(channel));
  self->response_handle = FL_BASIC_MESSAGE_CHANNEL_RESPONSE_HANDLE(g_object_ref(response_handle));
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetAvailableCamerasResponse, camera_linux_camera_api_get_available_cameras_response, CAMERA_LINUX, CAMERA_API_GET_AVAILABLE_CAMERAS_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetAvailableCamerasResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetAvailableCamerasResponse, camera_linux_camera_api_get_available_cameras_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_available_cameras_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetAvailableCamerasResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_available_cameras_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_available_cameras_response_init(CameraLinuxCameraApiGetAvailableCamerasResponse* self) {
}

static void camera_linux_camera_api_get_available_cameras_response_class_init(CameraLinuxCameraApiGetAvailableCamerasResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_available_cameras_response_dispose;
}

static CameraLinuxCameraApiGetAvailableCamerasResponse* camera_linux_camera_api_get_available_cameras_response_new(FlValue* return_value) {
  CameraLinuxCameraApiGetAvailableCamerasResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_RESPONSE(g_object_new(camera_linux_camera_api_get_available_cameras_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_ref(return_value));
  return self;
}

static CameraLinuxCameraApiGetAvailableCamerasResponse* camera_linux_camera_api_get_available_cameras_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetAvailableCamerasResponse* self = CAMERA_LINUX_CAMERA_API_GET_AVAILABLE_CAMERAS_RESPONSE(g_object_new(camera_linux_camera_api_get_available_cameras_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiCreateResponse, camera_linux_camera_api_create_response, CAMERA_LINUX, CAMERA_API_CREATE_RESPONSE, GObject)

struct _CameraLinuxCameraApiCreateResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiCreateResponse, camera_linux_camera_api_create_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_create_response_dispose(GObject* object) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_create_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_create_response_init(CameraLinuxCameraApiCreateResponse* self) {
}

static void camera_linux_camera_api_create_response_class_init(CameraLinuxCameraApiCreateResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_create_response_dispose;
}

static CameraLinuxCameraApiCreateResponse* camera_linux_camera_api_create_response_new(int64_t return_value) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(g_object_new(camera_linux_camera_api_create_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_int(return_value));
  return self;
}

static CameraLinuxCameraApiCreateResponse* camera_linux_camera_api_create_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiCreateResponse* self = CAMERA_LINUX_CAMERA_API_CREATE_RESPONSE(g_object_new(camera_linux_camera_api_create_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiInitializeResponse, camera_linux_camera_api_initialize_response, CAMERA_LINUX, CAMERA_API_INITIALIZE_RESPONSE, GObject)

struct _CameraLinuxCameraApiInitializeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiInitializeResponse, camera_linux_camera_api_initialize_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_initialize_response_dispose(GObject* object) {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_initialize_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_initialize_response_init(CameraLinuxCameraApiInitializeResponse* self) {
}

static void camera_linux_camera_api_initialize_response_class_init(CameraLinuxCameraApiInitializeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_initialize_response_dispose;
}

static CameraLinuxCameraApiInitializeResponse* camera_linux_camera_api_initialize_response_new() {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(g_object_new(camera_linux_camera_api_initialize_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiInitializeResponse* camera_linux_camera_api_initialize_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiInitializeResponse* self = CAMERA_LINUX_CAMERA_API_INITIALIZE_RESPONSE(g_object_new(camera_linux_camera_api_initialize_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStartImageStreamResponse, camera_linux_camera_api_start_image_stream_response, CAMERA_LINUX, CAMERA_API_START_IMAGE_STREAM_RESPONSE, GObject)

struct _CameraLinuxCameraApiStartImageStreamResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStartImageStreamResponse, camera_linux_camera_api_start_image_stream_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_start_image_stream_response_dispose(GObject* object) {
  CameraLinuxCameraApiStartImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_START_IMAGE_STREAM_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_start_image_stream_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_start_image_stream_response_init(CameraLinuxCameraApiStartImageStreamResponse* self) {
}

static void camera_linux_camera_api_start_image_stream_response_class_init(CameraLinuxCameraApiStartImageStreamResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_start_image_stream_response_dispose;
}

static CameraLinuxCameraApiStartImageStreamResponse* camera_linux_camera_api_start_image_stream_response_new() {
  CameraLinuxCameraApiStartImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_START_IMAGE_STREAM_RESPONSE(g_object_new(camera_linux_camera_api_start_image_stream_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiStartImageStreamResponse* camera_linux_camera_api_start_image_stream_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStartImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_START_IMAGE_STREAM_RESPONSE(g_object_new(camera_linux_camera_api_start_image_stream_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStopImageStreamResponse, camera_linux_camera_api_stop_image_stream_response, CAMERA_LINUX, CAMERA_API_STOP_IMAGE_STREAM_RESPONSE, GObject)

struct _CameraLinuxCameraApiStopImageStreamResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStopImageStreamResponse, camera_linux_camera_api_stop_image_stream_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_stop_image_stream_response_dispose(GObject* object) {
  CameraLinuxCameraApiStopImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_STOP_IMAGE_STREAM_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_stop_image_stream_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_stop_image_stream_response_init(CameraLinuxCameraApiStopImageStreamResponse* self) {
}

static void camera_linux_camera_api_stop_image_stream_response_class_init(CameraLinuxCameraApiStopImageStreamResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_stop_image_stream_response_dispose;
}

static CameraLinuxCameraApiStopImageStreamResponse* camera_linux_camera_api_stop_image_stream_response_new() {
  CameraLinuxCameraApiStopImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_STOP_IMAGE_STREAM_RESPONSE(g_object_new(camera_linux_camera_api_stop_image_stream_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiStopImageStreamResponse* camera_linux_camera_api_stop_image_stream_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStopImageStreamResponse* self = CAMERA_LINUX_CAMERA_API_STOP_IMAGE_STREAM_RESPONSE(g_object_new(camera_linux_camera_api_stop_image_stream_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiReceivedImageStreamDataResponse, camera_linux_camera_api_received_image_stream_data_response, CAMERA_LINUX, CAMERA_API_RECEIVED_IMAGE_STREAM_DATA_RESPONSE, GObject)

struct _CameraLinuxCameraApiReceivedImageStreamDataResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiReceivedImageStreamDataResponse, camera_linux_camera_api_received_image_stream_data_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_received_image_stream_data_response_dispose(GObject* object) {
  CameraLinuxCameraApiReceivedImageStreamDataResponse* self = CAMERA_LINUX_CAMERA_API_RECEIVED_IMAGE_STREAM_DATA_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_received_image_stream_data_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_received_image_stream_data_response_init(CameraLinuxCameraApiReceivedImageStreamDataResponse* self) {
}

static void camera_linux_camera_api_received_image_stream_data_response_class_init(CameraLinuxCameraApiReceivedImageStreamDataResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_received_image_stream_data_response_dispose;
}

static CameraLinuxCameraApiReceivedImageStreamDataResponse* camera_linux_camera_api_received_image_stream_data_response_new() {
  CameraLinuxCameraApiReceivedImageStreamDataResponse* self = CAMERA_LINUX_CAMERA_API_RECEIVED_IMAGE_STREAM_DATA_RESPONSE(g_object_new(camera_linux_camera_api_received_image_stream_data_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiReceivedImageStreamDataResponse* camera_linux_camera_api_received_image_stream_data_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiReceivedImageStreamDataResponse* self = CAMERA_LINUX_CAMERA_API_RECEIVED_IMAGE_STREAM_DATA_RESPONSE(g_object_new(camera_linux_camera_api_received_image_stream_data_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiDisposeResponse, camera_linux_camera_api_dispose_response, CAMERA_LINUX, CAMERA_API_DISPOSE_RESPONSE, GObject)

struct _CameraLinuxCameraApiDisposeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiDisposeResponse, camera_linux_camera_api_dispose_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_dispose_response_dispose(GObject* object) {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_dispose_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_dispose_response_init(CameraLinuxCameraApiDisposeResponse* self) {
}

static void camera_linux_camera_api_dispose_response_class_init(CameraLinuxCameraApiDisposeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_dispose_response_dispose;
}

static CameraLinuxCameraApiDisposeResponse* camera_linux_camera_api_dispose_response_new() {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(g_object_new(camera_linux_camera_api_dispose_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiDisposeResponse* camera_linux_camera_api_dispose_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiDisposeResponse* self = CAMERA_LINUX_CAMERA_API_DISPOSE_RESPONSE(g_object_new(camera_linux_camera_api_dispose_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiLockCaptureOrientationResponse, camera_linux_camera_api_lock_capture_orientation_response, CAMERA_LINUX, CAMERA_API_LOCK_CAPTURE_ORIENTATION_RESPONSE, GObject)

struct _CameraLinuxCameraApiLockCaptureOrientationResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiLockCaptureOrientationResponse, camera_linux_camera_api_lock_capture_orientation_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_lock_capture_orientation_response_dispose(GObject* object) {
  CameraLinuxCameraApiLockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_LOCK_CAPTURE_ORIENTATION_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_lock_capture_orientation_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_lock_capture_orientation_response_init(CameraLinuxCameraApiLockCaptureOrientationResponse* self) {
}

static void camera_linux_camera_api_lock_capture_orientation_response_class_init(CameraLinuxCameraApiLockCaptureOrientationResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_lock_capture_orientation_response_dispose;
}

static CameraLinuxCameraApiLockCaptureOrientationResponse* camera_linux_camera_api_lock_capture_orientation_response_new() {
  CameraLinuxCameraApiLockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_LOCK_CAPTURE_ORIENTATION_RESPONSE(g_object_new(camera_linux_camera_api_lock_capture_orientation_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiLockCaptureOrientationResponse* camera_linux_camera_api_lock_capture_orientation_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiLockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_LOCK_CAPTURE_ORIENTATION_RESPONSE(g_object_new(camera_linux_camera_api_lock_capture_orientation_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiUnlockCaptureOrientationResponse, camera_linux_camera_api_unlock_capture_orientation_response, CAMERA_LINUX, CAMERA_API_UNLOCK_CAPTURE_ORIENTATION_RESPONSE, GObject)

struct _CameraLinuxCameraApiUnlockCaptureOrientationResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiUnlockCaptureOrientationResponse, camera_linux_camera_api_unlock_capture_orientation_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_unlock_capture_orientation_response_dispose(GObject* object) {
  CameraLinuxCameraApiUnlockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_UNLOCK_CAPTURE_ORIENTATION_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_unlock_capture_orientation_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_unlock_capture_orientation_response_init(CameraLinuxCameraApiUnlockCaptureOrientationResponse* self) {
}

static void camera_linux_camera_api_unlock_capture_orientation_response_class_init(CameraLinuxCameraApiUnlockCaptureOrientationResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_unlock_capture_orientation_response_dispose;
}

static CameraLinuxCameraApiUnlockCaptureOrientationResponse* camera_linux_camera_api_unlock_capture_orientation_response_new() {
  CameraLinuxCameraApiUnlockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_UNLOCK_CAPTURE_ORIENTATION_RESPONSE(g_object_new(camera_linux_camera_api_unlock_capture_orientation_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiUnlockCaptureOrientationResponse* camera_linux_camera_api_unlock_capture_orientation_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiUnlockCaptureOrientationResponse* self = CAMERA_LINUX_CAMERA_API_UNLOCK_CAPTURE_ORIENTATION_RESPONSE(g_object_new(camera_linux_camera_api_unlock_capture_orientation_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiTakePictureResponse, camera_linux_camera_api_take_picture_response, CAMERA_LINUX, CAMERA_API_TAKE_PICTURE_RESPONSE, GObject)

struct _CameraLinuxCameraApiTakePictureResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiTakePictureResponse, camera_linux_camera_api_take_picture_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_take_picture_response_dispose(GObject* object) {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_take_picture_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_take_picture_response_init(CameraLinuxCameraApiTakePictureResponse* self) {
}

static void camera_linux_camera_api_take_picture_response_class_init(CameraLinuxCameraApiTakePictureResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_take_picture_response_dispose;
}

static CameraLinuxCameraApiTakePictureResponse* camera_linux_camera_api_take_picture_response_new(const gchar* return_value) {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(g_object_new(camera_linux_camera_api_take_picture_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(return_value));
  return self;
}

static CameraLinuxCameraApiTakePictureResponse* camera_linux_camera_api_take_picture_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiTakePictureResponse* self = CAMERA_LINUX_CAMERA_API_TAKE_PICTURE_RESPONSE(g_object_new(camera_linux_camera_api_take_picture_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiPrepareForVideoRecordingResponse, camera_linux_camera_api_prepare_for_video_recording_response, CAMERA_LINUX, CAMERA_API_PREPARE_FOR_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiPrepareForVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiPrepareForVideoRecordingResponse, camera_linux_camera_api_prepare_for_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_prepare_for_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiPrepareForVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PREPARE_FOR_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_prepare_for_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_prepare_for_video_recording_response_init(CameraLinuxCameraApiPrepareForVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_prepare_for_video_recording_response_class_init(CameraLinuxCameraApiPrepareForVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_prepare_for_video_recording_response_dispose;
}

static CameraLinuxCameraApiPrepareForVideoRecordingResponse* camera_linux_camera_api_prepare_for_video_recording_response_new() {
  CameraLinuxCameraApiPrepareForVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PREPARE_FOR_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_prepare_for_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiPrepareForVideoRecordingResponse* camera_linux_camera_api_prepare_for_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiPrepareForVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PREPARE_FOR_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_prepare_for_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStartVideoRecordingResponse, camera_linux_camera_api_start_video_recording_response, CAMERA_LINUX, CAMERA_API_START_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiStartVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStartVideoRecordingResponse, camera_linux_camera_api_start_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_start_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_start_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_start_video_recording_response_init(CameraLinuxCameraApiStartVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_start_video_recording_response_class_init(CameraLinuxCameraApiStartVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_start_video_recording_response_dispose;
}

static CameraLinuxCameraApiStartVideoRecordingResponse* camera_linux_camera_api_start_video_recording_response_new() {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_start_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiStartVideoRecordingResponse* camera_linux_camera_api_start_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStartVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_START_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_start_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiStopVideoRecordingResponse, camera_linux_camera_api_stop_video_recording_response, CAMERA_LINUX, CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiStopVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiStopVideoRecordingResponse, camera_linux_camera_api_stop_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_stop_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_stop_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_stop_video_recording_response_init(CameraLinuxCameraApiStopVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_stop_video_recording_response_class_init(CameraLinuxCameraApiStopVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_stop_video_recording_response_dispose;
}

static CameraLinuxCameraApiStopVideoRecordingResponse* camera_linux_camera_api_stop_video_recording_response_new(const gchar* return_value) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_stop_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(return_value));
  return self;
}

static CameraLinuxCameraApiStopVideoRecordingResponse* camera_linux_camera_api_stop_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiStopVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_STOP_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_stop_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiPauseVideoRecordingResponse, camera_linux_camera_api_pause_video_recording_response, CAMERA_LINUX, CAMERA_API_PAUSE_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiPauseVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiPauseVideoRecordingResponse, camera_linux_camera_api_pause_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_pause_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiPauseVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_pause_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_pause_video_recording_response_init(CameraLinuxCameraApiPauseVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_pause_video_recording_response_class_init(CameraLinuxCameraApiPauseVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_pause_video_recording_response_dispose;
}

static CameraLinuxCameraApiPauseVideoRecordingResponse* camera_linux_camera_api_pause_video_recording_response_new() {
  CameraLinuxCameraApiPauseVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_pause_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiPauseVideoRecordingResponse* camera_linux_camera_api_pause_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiPauseVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_pause_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiResumeVideoRecordingResponse, camera_linux_camera_api_resume_video_recording_response, CAMERA_LINUX, CAMERA_API_RESUME_VIDEO_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiResumeVideoRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiResumeVideoRecordingResponse, camera_linux_camera_api_resume_video_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_resume_video_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiResumeVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_VIDEO_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_resume_video_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_resume_video_recording_response_init(CameraLinuxCameraApiResumeVideoRecordingResponse* self) {
}

static void camera_linux_camera_api_resume_video_recording_response_class_init(CameraLinuxCameraApiResumeVideoRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_resume_video_recording_response_dispose;
}

static CameraLinuxCameraApiResumeVideoRecordingResponse* camera_linux_camera_api_resume_video_recording_response_new() {
  CameraLinuxCameraApiResumeVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_resume_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiResumeVideoRecordingResponse* camera_linux_camera_api_resume_video_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiResumeVideoRecordingResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_VIDEO_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_resume_video_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetFlashModeResponse, camera_linux_camera_api_set_flash_mode_response, CAMERA_LINUX, CAMERA_API_SET_FLASH_MODE_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetFlashModeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetFlashModeResponse, camera_linux_camera_api_set_flash_mode_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_flash_mode_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetFlashModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FLASH_MODE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_flash_mode_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_flash_mode_response_init(CameraLinuxCameraApiSetFlashModeResponse* self) {
}

static void camera_linux_camera_api_set_flash_mode_response_class_init(CameraLinuxCameraApiSetFlashModeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_flash_mode_response_dispose;
}

static CameraLinuxCameraApiSetFlashModeResponse* camera_linux_camera_api_set_flash_mode_response_new() {
  CameraLinuxCameraApiSetFlashModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FLASH_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_flash_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetFlashModeResponse* camera_linux_camera_api_set_flash_mode_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetFlashModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FLASH_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_flash_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetExposureModeResponse, camera_linux_camera_api_set_exposure_mode_response, CAMERA_LINUX, CAMERA_API_SET_EXPOSURE_MODE_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetExposureModeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetExposureModeResponse, camera_linux_camera_api_set_exposure_mode_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_exposure_mode_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_exposure_mode_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_exposure_mode_response_init(CameraLinuxCameraApiSetExposureModeResponse* self) {
}

static void camera_linux_camera_api_set_exposure_mode_response_class_init(CameraLinuxCameraApiSetExposureModeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_exposure_mode_response_dispose;
}

static CameraLinuxCameraApiSetExposureModeResponse* camera_linux_camera_api_set_exposure_mode_response_new() {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetExposureModeResponse* camera_linux_camera_api_set_exposure_mode_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetExposureModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetExposurePointResponse, camera_linux_camera_api_set_exposure_point_response, CAMERA_LINUX, CAMERA_API_SET_EXPOSURE_POINT_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetExposurePointResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetExposurePointResponse, camera_linux_camera_api_set_exposure_point_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_exposure_point_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetExposurePointResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_POINT_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_exposure_point_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_exposure_point_response_init(CameraLinuxCameraApiSetExposurePointResponse* self) {
}

static void camera_linux_camera_api_set_exposure_point_response_class_init(CameraLinuxCameraApiSetExposurePointResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_exposure_point_response_dispose;
}

static CameraLinuxCameraApiSetExposurePointResponse* camera_linux_camera_api_set_exposure_point_response_new() {
  CameraLinuxCameraApiSetExposurePointResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_POINT_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_point_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetExposurePointResponse* camera_linux_camera_api_set_exposure_point_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetExposurePointResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_POINT_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_point_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetLensPositionResponse, camera_linux_camera_api_set_lens_position_response, CAMERA_LINUX, CAMERA_API_SET_LENS_POSITION_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetLensPositionResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetLensPositionResponse, camera_linux_camera_api_set_lens_position_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_lens_position_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetLensPositionResponse* self = CAMERA_LINUX_CAMERA_API_SET_LENS_POSITION_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_lens_position_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_lens_position_response_init(CameraLinuxCameraApiSetLensPositionResponse* self) {
}

static void camera_linux_camera_api_set_lens_position_response_class_init(CameraLinuxCameraApiSetLensPositionResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_lens_position_response_dispose;
}

static CameraLinuxCameraApiSetLensPositionResponse* camera_linux_camera_api_set_lens_position_response_new() {
  CameraLinuxCameraApiSetLensPositionResponse* self = CAMERA_LINUX_CAMERA_API_SET_LENS_POSITION_RESPONSE(g_object_new(camera_linux_camera_api_set_lens_position_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetLensPositionResponse* camera_linux_camera_api_set_lens_position_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetLensPositionResponse* self = CAMERA_LINUX_CAMERA_API_SET_LENS_POSITION_RESPONSE(g_object_new(camera_linux_camera_api_set_lens_position_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetMinExposureOffsetResponse, camera_linux_camera_api_get_min_exposure_offset_response, CAMERA_LINUX, CAMERA_API_GET_MIN_EXPOSURE_OFFSET_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetMinExposureOffsetResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetMinExposureOffsetResponse, camera_linux_camera_api_get_min_exposure_offset_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_min_exposure_offset_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetMinExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_EXPOSURE_OFFSET_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_min_exposure_offset_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_min_exposure_offset_response_init(CameraLinuxCameraApiGetMinExposureOffsetResponse* self) {
}

static void camera_linux_camera_api_get_min_exposure_offset_response_class_init(CameraLinuxCameraApiGetMinExposureOffsetResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_min_exposure_offset_response_dispose;
}

static CameraLinuxCameraApiGetMinExposureOffsetResponse* camera_linux_camera_api_get_min_exposure_offset_response_new(double return_value) {
  CameraLinuxCameraApiGetMinExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_get_min_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_float(return_value));
  return self;
}

static CameraLinuxCameraApiGetMinExposureOffsetResponse* camera_linux_camera_api_get_min_exposure_offset_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetMinExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_get_min_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetMaxExposureOffsetResponse, camera_linux_camera_api_get_max_exposure_offset_response, CAMERA_LINUX, CAMERA_API_GET_MAX_EXPOSURE_OFFSET_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetMaxExposureOffsetResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetMaxExposureOffsetResponse, camera_linux_camera_api_get_max_exposure_offset_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_max_exposure_offset_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetMaxExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_EXPOSURE_OFFSET_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_max_exposure_offset_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_max_exposure_offset_response_init(CameraLinuxCameraApiGetMaxExposureOffsetResponse* self) {
}

static void camera_linux_camera_api_get_max_exposure_offset_response_class_init(CameraLinuxCameraApiGetMaxExposureOffsetResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_max_exposure_offset_response_dispose;
}

static CameraLinuxCameraApiGetMaxExposureOffsetResponse* camera_linux_camera_api_get_max_exposure_offset_response_new(double return_value) {
  CameraLinuxCameraApiGetMaxExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_get_max_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_float(return_value));
  return self;
}

static CameraLinuxCameraApiGetMaxExposureOffsetResponse* camera_linux_camera_api_get_max_exposure_offset_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetMaxExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_get_max_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetExposureOffsetResponse, camera_linux_camera_api_set_exposure_offset_response, CAMERA_LINUX, CAMERA_API_SET_EXPOSURE_OFFSET_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetExposureOffsetResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetExposureOffsetResponse, camera_linux_camera_api_set_exposure_offset_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_exposure_offset_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_OFFSET_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_exposure_offset_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_exposure_offset_response_init(CameraLinuxCameraApiSetExposureOffsetResponse* self) {
}

static void camera_linux_camera_api_set_exposure_offset_response_class_init(CameraLinuxCameraApiSetExposureOffsetResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_exposure_offset_response_dispose;
}

static CameraLinuxCameraApiSetExposureOffsetResponse* camera_linux_camera_api_set_exposure_offset_response_new() {
  CameraLinuxCameraApiSetExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetExposureOffsetResponse* camera_linux_camera_api_set_exposure_offset_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetExposureOffsetResponse* self = CAMERA_LINUX_CAMERA_API_SET_EXPOSURE_OFFSET_RESPONSE(g_object_new(camera_linux_camera_api_set_exposure_offset_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetFocusModeResponse, camera_linux_camera_api_set_focus_mode_response, CAMERA_LINUX, CAMERA_API_SET_FOCUS_MODE_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetFocusModeResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetFocusModeResponse, camera_linux_camera_api_set_focus_mode_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_focus_mode_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_focus_mode_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_focus_mode_response_init(CameraLinuxCameraApiSetFocusModeResponse* self) {
}

static void camera_linux_camera_api_set_focus_mode_response_class_init(CameraLinuxCameraApiSetFocusModeResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_focus_mode_response_dispose;
}

static CameraLinuxCameraApiSetFocusModeResponse* camera_linux_camera_api_set_focus_mode_response_new() {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetFocusModeResponse* camera_linux_camera_api_set_focus_mode_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetFocusModeResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_MODE_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_mode_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetFocusPointResponse, camera_linux_camera_api_set_focus_point_response, CAMERA_LINUX, CAMERA_API_SET_FOCUS_POINT_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetFocusPointResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetFocusPointResponse, camera_linux_camera_api_set_focus_point_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_focus_point_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetFocusPointResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_POINT_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_focus_point_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_focus_point_response_init(CameraLinuxCameraApiSetFocusPointResponse* self) {
}

static void camera_linux_camera_api_set_focus_point_response_class_init(CameraLinuxCameraApiSetFocusPointResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_focus_point_response_dispose;
}

static CameraLinuxCameraApiSetFocusPointResponse* camera_linux_camera_api_set_focus_point_response_new() {
  CameraLinuxCameraApiSetFocusPointResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_POINT_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_point_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetFocusPointResponse* camera_linux_camera_api_set_focus_point_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetFocusPointResponse* self = CAMERA_LINUX_CAMERA_API_SET_FOCUS_POINT_RESPONSE(g_object_new(camera_linux_camera_api_set_focus_point_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetMinZoomLevelResponse, camera_linux_camera_api_get_min_zoom_level_response, CAMERA_LINUX, CAMERA_API_GET_MIN_ZOOM_LEVEL_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetMinZoomLevelResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetMinZoomLevelResponse, camera_linux_camera_api_get_min_zoom_level_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_min_zoom_level_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetMinZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_ZOOM_LEVEL_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_min_zoom_level_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_min_zoom_level_response_init(CameraLinuxCameraApiGetMinZoomLevelResponse* self) {
}

static void camera_linux_camera_api_get_min_zoom_level_response_class_init(CameraLinuxCameraApiGetMinZoomLevelResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_min_zoom_level_response_dispose;
}

static CameraLinuxCameraApiGetMinZoomLevelResponse* camera_linux_camera_api_get_min_zoom_level_response_new(double return_value) {
  CameraLinuxCameraApiGetMinZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_get_min_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_float(return_value));
  return self;
}

static CameraLinuxCameraApiGetMinZoomLevelResponse* camera_linux_camera_api_get_min_zoom_level_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetMinZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MIN_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_get_min_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiGetMaxZoomLevelResponse, camera_linux_camera_api_get_max_zoom_level_response, CAMERA_LINUX, CAMERA_API_GET_MAX_ZOOM_LEVEL_RESPONSE, GObject)

struct _CameraLinuxCameraApiGetMaxZoomLevelResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiGetMaxZoomLevelResponse, camera_linux_camera_api_get_max_zoom_level_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_get_max_zoom_level_response_dispose(GObject* object) {
  CameraLinuxCameraApiGetMaxZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_ZOOM_LEVEL_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_get_max_zoom_level_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_get_max_zoom_level_response_init(CameraLinuxCameraApiGetMaxZoomLevelResponse* self) {
}

static void camera_linux_camera_api_get_max_zoom_level_response_class_init(CameraLinuxCameraApiGetMaxZoomLevelResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_get_max_zoom_level_response_dispose;
}

static CameraLinuxCameraApiGetMaxZoomLevelResponse* camera_linux_camera_api_get_max_zoom_level_response_new(double return_value) {
  CameraLinuxCameraApiGetMaxZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_get_max_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_float(return_value));
  return self;
}

static CameraLinuxCameraApiGetMaxZoomLevelResponse* camera_linux_camera_api_get_max_zoom_level_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiGetMaxZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_GET_MAX_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_get_max_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetZoomLevelResponse, camera_linux_camera_api_set_zoom_level_response, CAMERA_LINUX, CAMERA_API_SET_ZOOM_LEVEL_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetZoomLevelResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetZoomLevelResponse, camera_linux_camera_api_set_zoom_level_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_zoom_level_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_SET_ZOOM_LEVEL_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_zoom_level_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_zoom_level_response_init(CameraLinuxCameraApiSetZoomLevelResponse* self) {
}

static void camera_linux_camera_api_set_zoom_level_response_class_init(CameraLinuxCameraApiSetZoomLevelResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_zoom_level_response_dispose;
}

static CameraLinuxCameraApiSetZoomLevelResponse* camera_linux_camera_api_set_zoom_level_response_new() {
  CameraLinuxCameraApiSetZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_SET_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_set_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetZoomLevelResponse* camera_linux_camera_api_set_zoom_level_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetZoomLevelResponse* self = CAMERA_LINUX_CAMERA_API_SET_ZOOM_LEVEL_RESPONSE(g_object_new(camera_linux_camera_api_set_zoom_level_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiPausePreviewResponse, camera_linux_camera_api_pause_preview_response, CAMERA_LINUX, CAMERA_API_PAUSE_PREVIEW_RESPONSE, GObject)

struct _CameraLinuxCameraApiPausePreviewResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiPausePreviewResponse, camera_linux_camera_api_pause_preview_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_pause_preview_response_dispose(GObject* object) {
  CameraLinuxCameraApiPausePreviewResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_PREVIEW_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_pause_preview_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_pause_preview_response_init(CameraLinuxCameraApiPausePreviewResponse* self) {
}

static void camera_linux_camera_api_pause_preview_response_class_init(CameraLinuxCameraApiPausePreviewResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_pause_preview_response_dispose;
}

static CameraLinuxCameraApiPausePreviewResponse* camera_linux_camera_api_pause_preview_response_new() {
  CameraLinuxCameraApiPausePreviewResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_PREVIEW_RESPONSE(g_object_new(camera_linux_camera_api_pause_preview_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiPausePreviewResponse* camera_linux_camera_api_pause_preview_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiPausePreviewResponse* self = CAMERA_LINUX_CAMERA_API_PAUSE_PREVIEW_RESPONSE(g_object_new(camera_linux_camera_api_pause_preview_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiResumePreviewResponse, camera_linux_camera_api_resume_preview_response, CAMERA_LINUX, CAMERA_API_RESUME_PREVIEW_RESPONSE, GObject)

struct _CameraLinuxCameraApiResumePreviewResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiResumePreviewResponse, camera_linux_camera_api_resume_preview_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_resume_preview_response_dispose(GObject* object) {
  CameraLinuxCameraApiResumePreviewResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_PREVIEW_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_resume_preview_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_resume_preview_response_init(CameraLinuxCameraApiResumePreviewResponse* self) {
}

static void camera_linux_camera_api_resume_preview_response_class_init(CameraLinuxCameraApiResumePreviewResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_resume_preview_response_dispose;
}

static CameraLinuxCameraApiResumePreviewResponse* camera_linux_camera_api_resume_preview_response_new() {
  CameraLinuxCameraApiResumePreviewResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_PREVIEW_RESPONSE(g_object_new(camera_linux_camera_api_resume_preview_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiResumePreviewResponse* camera_linux_camera_api_resume_preview_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiResumePreviewResponse* self = CAMERA_LINUX_CAMERA_API_RESUME_PREVIEW_RESPONSE(g_object_new(camera_linux_camera_api_resume_preview_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse, camera_linux_camera_api_update_description_while_recording_response, CAMERA_LINUX, CAMERA_API_UPDATE_DESCRIPTION_WHILE_RECORDING_RESPONSE, GObject)

struct _CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse, camera_linux_camera_api_update_description_while_recording_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_update_description_while_recording_response_dispose(GObject* object) {
  CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* self = CAMERA_LINUX_CAMERA_API_UPDATE_DESCRIPTION_WHILE_RECORDING_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_update_description_while_recording_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_update_description_while_recording_response_init(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* self) {
}

static void camera_linux_camera_api_update_description_while_recording_response_class_init(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_update_description_while_recording_response_dispose;
}

static CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* camera_linux_camera_api_update_description_while_recording_response_new() {
  CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* self = CAMERA_LINUX_CAMERA_API_UPDATE_DESCRIPTION_WHILE_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_update_description_while_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* camera_linux_camera_api_update_description_while_recording_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse* self = CAMERA_LINUX_CAMERA_API_UPDATE_DESCRIPTION_WHILE_RECORDING_RESPONSE(g_object_new(camera_linux_camera_api_update_description_while_recording_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

G_DECLARE_FINAL_TYPE(CameraLinuxCameraApiSetImageFileFormatResponse, camera_linux_camera_api_set_image_file_format_response, CAMERA_LINUX, CAMERA_API_SET_IMAGE_FILE_FORMAT_RESPONSE, GObject)

struct _CameraLinuxCameraApiSetImageFileFormatResponse {
  GObject parent_instance;

  FlValue* value;
};

G_DEFINE_TYPE(CameraLinuxCameraApiSetImageFileFormatResponse, camera_linux_camera_api_set_image_file_format_response, G_TYPE_OBJECT)

static void camera_linux_camera_api_set_image_file_format_response_dispose(GObject* object) {
  CameraLinuxCameraApiSetImageFileFormatResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FILE_FORMAT_RESPONSE(object);
  g_clear_pointer(&self->value, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_api_set_image_file_format_response_parent_class)->dispose(object);
}

static void camera_linux_camera_api_set_image_file_format_response_init(CameraLinuxCameraApiSetImageFileFormatResponse* self) {
}

static void camera_linux_camera_api_set_image_file_format_response_class_init(CameraLinuxCameraApiSetImageFileFormatResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_set_image_file_format_response_dispose;
}

static CameraLinuxCameraApiSetImageFileFormatResponse* camera_linux_camera_api_set_image_file_format_response_new() {
  CameraLinuxCameraApiSetImageFileFormatResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FILE_FORMAT_RESPONSE(g_object_new(camera_linux_camera_api_set_image_file_format_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_null());
  return self;
}

static CameraLinuxCameraApiSetImageFileFormatResponse* camera_linux_camera_api_set_image_file_format_response_new_error(const gchar* code, const gchar* message, FlValue* details) {
  CameraLinuxCameraApiSetImageFileFormatResponse* self = CAMERA_LINUX_CAMERA_API_SET_IMAGE_FILE_FORMAT_RESPONSE(g_object_new(camera_linux_camera_api_set_image_file_format_response_get_type(), nullptr));
  self->value = fl_value_new_list();
  fl_value_append_take(self->value, fl_value_new_string(code));
  fl_value_append_take(self->value, fl_value_new_string(message != nullptr ? message : ""));
  fl_value_append_take(self->value, details != nullptr ? fl_value_ref(details) : fl_value_new_null());
  return self;
}

struct _CameraLinuxCameraApi {
  GObject parent_instance;

  const CameraLinuxCameraApiVTable* vtable;
  gpointer user_data;
  GDestroyNotify user_data_free_func;
};

G_DEFINE_TYPE(CameraLinuxCameraApi, camera_linux_camera_api, G_TYPE_OBJECT)

static void camera_linux_camera_api_dispose(GObject* object) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(object);
  if (self->user_data != nullptr) {
    self->user_data_free_func(self->user_data);
  }
  self->user_data = nullptr;
  G_OBJECT_CLASS(camera_linux_camera_api_parent_class)->dispose(object);
}

static void camera_linux_camera_api_init(CameraLinuxCameraApi* self) {
}

static void camera_linux_camera_api_class_init(CameraLinuxCameraApiClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_api_dispose;
}

static CameraLinuxCameraApi* camera_linux_camera_api_new(const CameraLinuxCameraApiVTable* vtable, gpointer user_data, GDestroyNotify user_data_free_func) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(g_object_new(camera_linux_camera_api_get_type(), nullptr));
  self->vtable = vtable;
  self->user_data = user_data;
  self->user_data_free_func = user_data_free_func;
  return self;
}

static void camera_linux_camera_api_get_available_cameras_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_available_cameras == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_available_cameras(handle, self->user_data);
}

static void camera_linux_camera_api_create_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->create == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  const gchar* camera_name = fl_value_get_string(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformMediaSettings* settings = CAMERA_LINUX_PLATFORM_MEDIA_SETTINGS(fl_value_get_custom_value_object(value1));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->create(camera_name, settings, handle, self->user_data);
}

static void camera_linux_camera_api_initialize_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->initialize == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  FlValue* value1 = fl_value_get_list_value(message_, 1);
  CameraLinuxPlatformImageFormatGroup image_format = static_cast<CameraLinuxPlatformImageFormatGroup>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value1)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->initialize(camera_id, image_format, handle, self->user_data);
}

static void camera_linux_camera_api_start_image_stream_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->start_image_stream == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->start_image_stream(handle, self->user_data);
}

static void camera_linux_camera_api_stop_image_stream_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->stop_image_stream == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->stop_image_stream(handle, self->user_data);
}

static void camera_linux_camera_api_received_image_stream_data_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->received_image_stream_data == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->received_image_stream_data(handle, self->user_data);
}

static void camera_linux_camera_api_dispose_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->dispose == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  int64_t camera_id = fl_value_get_int(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->dispose(camera_id, handle, self->user_data);
}

static void camera_linux_camera_api_lock_capture_orientation_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->lock_capture_orientation == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformDeviceOrientation orientation = static_cast<CameraLinuxPlatformDeviceOrientation>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->lock_capture_orientation(orientation, handle, self->user_data);
}

static void camera_linux_camera_api_unlock_capture_orientation_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->unlock_capture_orientation == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->unlock_capture_orientation(handle, self->user_data);
}

static void camera_linux_camera_api_take_picture_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->take_picture == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->take_picture(handle, self->user_data);
}

static void camera_linux_camera_api_prepare_for_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->prepare_for_video_recording == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->prepare_for_video_recording(handle, self->user_data);
}

static void camera_linux_camera_api_start_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->start_video_recording == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  gboolean enable_stream = fl_value_get_bool(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->start_video_recording(enable_stream, handle, self->user_data);
}

static void camera_linux_camera_api_stop_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->stop_video_recording == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->stop_video_recording(handle, self->user_data);
}

static void camera_linux_camera_api_pause_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->pause_video_recording == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->pause_video_recording(handle, self->user_data);
}

static void camera_linux_camera_api_resume_video_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->resume_video_recording == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->resume_video_recording(handle, self->user_data);
}

static void camera_linux_camera_api_set_flash_mode_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_flash_mode == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformFlashMode mode = static_cast<CameraLinuxPlatformFlashMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_flash_mode(mode, handle, self->user_data);
}

static void camera_linux_camera_api_set_exposure_mode_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_exposure_mode == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformExposureMode mode = static_cast<CameraLinuxPlatformExposureMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_exposure_mode(mode, handle, self->user_data);
}

static void camera_linux_camera_api_set_exposure_point_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_exposure_point == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformPoint* point = CAMERA_LINUX_PLATFORM_POINT(fl_value_get_custom_value_object(value0));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_exposure_point(point, handle, self->user_data);
}

static void camera_linux_camera_api_set_lens_position_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_lens_position == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  double position = fl_value_get_float(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_lens_position(position, handle, self->user_data);
}

static void camera_linux_camera_api_get_min_exposure_offset_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_min_exposure_offset == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_min_exposure_offset(handle, self->user_data);
}

static void camera_linux_camera_api_get_max_exposure_offset_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_max_exposure_offset == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_max_exposure_offset(handle, self->user_data);
}

static void camera_linux_camera_api_set_exposure_offset_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_exposure_offset == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  double offset = fl_value_get_float(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_exposure_offset(offset, handle, self->user_data);
}

static void camera_linux_camera_api_set_focus_mode_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_focus_mode == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformFocusMode mode = static_cast<CameraLinuxPlatformFocusMode>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_focus_mode(mode, handle, self->user_data);
}

static void camera_linux_camera_api_set_focus_point_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_focus_point == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformPoint* point = CAMERA_LINUX_PLATFORM_POINT(fl_value_get_custom_value_object(value0));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_focus_point(point, handle, self->user_data);
}

static void camera_linux_camera_api_get_min_zoom_level_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_min_zoom_level == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_min_zoom_level(handle, self->user_data);
}

static void camera_linux_camera_api_get_max_zoom_level_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->get_max_zoom_level == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->get_max_zoom_level(handle, self->user_data);
}

static void camera_linux_camera_api_set_zoom_level_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_zoom_level == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  double zoom = fl_value_get_float(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_zoom_level(zoom, handle, self->user_data);
}

static void camera_linux_camera_api_pause_preview_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->pause_preview == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->pause_preview(handle, self->user_data);
}

static void camera_linux_camera_api_resume_preview_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->resume_preview == nullptr) {
    return;
  }

  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->resume_preview(handle, self->user_data);
}

static void camera_linux_camera_api_update_description_while_recording_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->update_description_while_recording == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  const gchar* camera_name = fl_value_get_string(value0);
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->update_description_while_recording(camera_name, handle, self->user_data);
}

static void camera_linux_camera_api_set_image_file_format_cb(FlBasicMessageChannel* channel, FlValue* message_, FlBasicMessageChannelResponseHandle* response_handle, gpointer user_data) {
  CameraLinuxCameraApi* self = CAMERA_LINUX_CAMERA_API(user_data);

  if (self->vtable == nullptr || self->vtable->set_image_file_format == nullptr) {
    return;
  }

  FlValue* value0 = fl_value_get_list_value(message_, 0);
  CameraLinuxPlatformImageFileFormat format = static_cast<CameraLinuxPlatformImageFileFormat>(fl_value_get_int(reinterpret_cast<FlValue*>(const_cast<gpointer>(fl_value_get_custom_value(value0)))));
  g_autoptr(CameraLinuxCameraApiResponseHandle) handle = camera_linux_camera_api_response_handle_new(channel, response_handle);
  self->vtable->set_image_file_format(format, handle, self->user_data);
}

void camera_linux_camera_api_set_method_handlers(FlBinaryMessenger* messenger, const gchar* suffix, const CameraLinuxCameraApiVTable* vtable, gpointer user_data, GDestroyNotify user_data_free_func) {
  g_autofree gchar* dot_suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  g_autoptr(CameraLinuxCameraApi) api_data = camera_linux_camera_api_new(vtable, user_data, user_data_free_func);

  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  g_autofree gchar* get_available_cameras_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getAvailableCameras%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_available_cameras_channel = fl_basic_message_channel_new(messenger, get_available_cameras_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_available_cameras_channel, camera_linux_camera_api_get_available_cameras_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* create_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.create%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) create_channel = fl_basic_message_channel_new(messenger, create_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(create_channel, camera_linux_camera_api_create_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* initialize_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.initialize%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) initialize_channel = fl_basic_message_channel_new(messenger, initialize_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(initialize_channel, camera_linux_camera_api_initialize_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* start_image_stream_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startImageStream%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_image_stream_channel = fl_basic_message_channel_new(messenger, start_image_stream_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_image_stream_channel, camera_linux_camera_api_start_image_stream_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* stop_image_stream_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopImageStream%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_image_stream_channel = fl_basic_message_channel_new(messenger, stop_image_stream_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_image_stream_channel, camera_linux_camera_api_stop_image_stream_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* received_image_stream_data_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.receivedImageStreamData%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) received_image_stream_data_channel = fl_basic_message_channel_new(messenger, received_image_stream_data_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(received_image_stream_data_channel, camera_linux_camera_api_received_image_stream_data_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* dispose_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.dispose%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) dispose_channel = fl_basic_message_channel_new(messenger, dispose_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(dispose_channel, camera_linux_camera_api_dispose_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* lock_capture_orientation_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.lockCaptureOrientation%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) lock_capture_orientation_channel = fl_basic_message_channel_new(messenger, lock_capture_orientation_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(lock_capture_orientation_channel, camera_linux_camera_api_lock_capture_orientation_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* unlock_capture_orientation_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.unlockCaptureOrientation%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) unlock_capture_orientation_channel = fl_basic_message_channel_new(messenger, unlock_capture_orientation_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(unlock_capture_orientation_channel, camera_linux_camera_api_unlock_capture_orientation_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* take_picture_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.takePicture%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) take_picture_channel = fl_basic_message_channel_new(messenger, take_picture_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(take_picture_channel, camera_linux_camera_api_take_picture_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* prepare_for_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.prepareForVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) prepare_for_video_recording_channel = fl_basic_message_channel_new(messenger, prepare_for_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(prepare_for_video_recording_channel, camera_linux_camera_api_prepare_for_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* start_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_video_recording_channel = fl_basic_message_channel_new(messenger, start_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_video_recording_channel, camera_linux_camera_api_start_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* stop_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_video_recording_channel = fl_basic_message_channel_new(messenger, stop_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_video_recording_channel, camera_linux_camera_api_stop_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* pause_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.pauseVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) pause_video_recording_channel = fl_basic_message_channel_new(messenger, pause_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(pause_video_recording_channel, camera_linux_camera_api_pause_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* resume_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.resumeVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) resume_video_recording_channel = fl_basic_message_channel_new(messenger, resume_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(resume_video_recording_channel, camera_linux_camera_api_resume_video_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_flash_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFlashMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_flash_mode_channel = fl_basic_message_channel_new(messenger, set_flash_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_flash_mode_channel, camera_linux_camera_api_set_flash_mode_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_exposure_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_mode_channel = fl_basic_message_channel_new(messenger, set_exposure_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_mode_channel, camera_linux_camera_api_set_exposure_mode_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_exposure_point_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposurePoint%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_point_channel = fl_basic_message_channel_new(messenger, set_exposure_point_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_point_channel, camera_linux_camera_api_set_exposure_point_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_lens_position_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setLensPosition%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_lens_position_channel = fl_basic_message_channel_new(messenger, set_lens_position_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_lens_position_channel, camera_linux_camera_api_set_lens_position_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* get_min_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMinExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_min_exposure_offset_channel = fl_basic_message_channel_new(messenger, get_min_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_min_exposure_offset_channel, camera_linux_camera_api_get_min_exposure_offset_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* get_max_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMaxExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_max_exposure_offset_channel = fl_basic_message_channel_new(messenger, get_max_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_max_exposure_offset_channel, camera_linux_camera_api_get_max_exposure_offset_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_offset_channel = fl_basic_message_channel_new(messenger, set_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_offset_channel, camera_linux_camera_api_set_exposure_offset_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_focus_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_mode_channel = fl_basic_message_channel_new(messenger, set_focus_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_mode_channel, camera_linux_camera_api_set_focus_mode_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_focus_point_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusPoint%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_point_channel = fl_basic_message_channel_new(messenger, set_focus_point_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_point_channel, camera_linux_camera_api_set_focus_point_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* get_min_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMinZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_min_zoom_level_channel = fl_basic_message_channel_new(messenger, get_min_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_min_zoom_level_channel, camera_linux_camera_api_get_min_zoom_level_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* get_max_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMaxZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_max_zoom_level_channel = fl_basic_message_channel_new(messenger, get_max_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_max_zoom_level_channel, camera_linux_camera_api_get_max_zoom_level_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_zoom_level_channel = fl_basic_message_channel_new(messenger, set_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_zoom_level_channel, camera_linux_camera_api_set_zoom_level_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* pause_preview_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.pausePreview%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) pause_preview_channel = fl_basic_message_channel_new(messenger, pause_preview_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(pause_preview_channel, camera_linux_camera_api_pause_preview_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* resume_preview_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.resumePreview%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) resume_preview_channel = fl_basic_message_channel_new(messenger, resume_preview_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(resume_preview_channel, camera_linux_camera_api_resume_preview_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* update_description_while_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.updateDescriptionWhileRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) update_description_while_recording_channel = fl_basic_message_channel_new(messenger, update_description_while_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(update_description_while_recording_channel, camera_linux_camera_api_update_description_while_recording_cb, g_object_ref(api_data), g_object_unref);
  g_autofree gchar* set_image_file_format_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setImageFileFormat%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_image_file_format_channel = fl_basic_message_channel_new(messenger, set_image_file_format_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_image_file_format_channel, camera_linux_camera_api_set_image_file_format_cb, g_object_ref(api_data), g_object_unref);
}

void camera_linux_camera_api_clear_method_handlers(FlBinaryMessenger* messenger, const gchar* suffix) {
  g_autofree gchar* dot_suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");

  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  g_autofree gchar* get_available_cameras_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getAvailableCameras%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_available_cameras_channel = fl_basic_message_channel_new(messenger, get_available_cameras_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_available_cameras_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* create_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.create%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) create_channel = fl_basic_message_channel_new(messenger, create_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(create_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* initialize_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.initialize%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) initialize_channel = fl_basic_message_channel_new(messenger, initialize_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(initialize_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* start_image_stream_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startImageStream%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_image_stream_channel = fl_basic_message_channel_new(messenger, start_image_stream_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_image_stream_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* stop_image_stream_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopImageStream%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_image_stream_channel = fl_basic_message_channel_new(messenger, stop_image_stream_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_image_stream_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* received_image_stream_data_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.receivedImageStreamData%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) received_image_stream_data_channel = fl_basic_message_channel_new(messenger, received_image_stream_data_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(received_image_stream_data_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* dispose_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.dispose%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) dispose_channel = fl_basic_message_channel_new(messenger, dispose_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(dispose_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* lock_capture_orientation_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.lockCaptureOrientation%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) lock_capture_orientation_channel = fl_basic_message_channel_new(messenger, lock_capture_orientation_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(lock_capture_orientation_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* unlock_capture_orientation_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.unlockCaptureOrientation%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) unlock_capture_orientation_channel = fl_basic_message_channel_new(messenger, unlock_capture_orientation_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(unlock_capture_orientation_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* take_picture_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.takePicture%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) take_picture_channel = fl_basic_message_channel_new(messenger, take_picture_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(take_picture_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* prepare_for_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.prepareForVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) prepare_for_video_recording_channel = fl_basic_message_channel_new(messenger, prepare_for_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(prepare_for_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* start_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.startVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) start_video_recording_channel = fl_basic_message_channel_new(messenger, start_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(start_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* stop_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.stopVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) stop_video_recording_channel = fl_basic_message_channel_new(messenger, stop_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(stop_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* pause_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.pauseVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) pause_video_recording_channel = fl_basic_message_channel_new(messenger, pause_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(pause_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* resume_video_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.resumeVideoRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) resume_video_recording_channel = fl_basic_message_channel_new(messenger, resume_video_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(resume_video_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_flash_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFlashMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_flash_mode_channel = fl_basic_message_channel_new(messenger, set_flash_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_flash_mode_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_exposure_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_mode_channel = fl_basic_message_channel_new(messenger, set_exposure_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_mode_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_exposure_point_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposurePoint%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_point_channel = fl_basic_message_channel_new(messenger, set_exposure_point_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_point_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_lens_position_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setLensPosition%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_lens_position_channel = fl_basic_message_channel_new(messenger, set_lens_position_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_lens_position_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* get_min_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMinExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_min_exposure_offset_channel = fl_basic_message_channel_new(messenger, get_min_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_min_exposure_offset_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* get_max_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMaxExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_max_exposure_offset_channel = fl_basic_message_channel_new(messenger, get_max_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_max_exposure_offset_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_exposure_offset_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setExposureOffset%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_exposure_offset_channel = fl_basic_message_channel_new(messenger, set_exposure_offset_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_exposure_offset_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_focus_mode_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusMode%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_mode_channel = fl_basic_message_channel_new(messenger, set_focus_mode_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_mode_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_focus_point_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setFocusPoint%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_focus_point_channel = fl_basic_message_channel_new(messenger, set_focus_point_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_focus_point_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* get_min_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMinZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_min_zoom_level_channel = fl_basic_message_channel_new(messenger, get_min_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_min_zoom_level_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* get_max_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.getMaxZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) get_max_zoom_level_channel = fl_basic_message_channel_new(messenger, get_max_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(get_max_zoom_level_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_zoom_level_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setZoomLevel%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_zoom_level_channel = fl_basic_message_channel_new(messenger, set_zoom_level_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_zoom_level_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* pause_preview_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.pausePreview%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) pause_preview_channel = fl_basic_message_channel_new(messenger, pause_preview_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(pause_preview_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* resume_preview_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.resumePreview%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) resume_preview_channel = fl_basic_message_channel_new(messenger, resume_preview_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(resume_preview_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* update_description_while_recording_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.updateDescriptionWhileRecording%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) update_description_while_recording_channel = fl_basic_message_channel_new(messenger, update_description_while_recording_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(update_description_while_recording_channel, nullptr, nullptr, nullptr);
  g_autofree gchar* set_image_file_format_channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraApi.setImageFileFormat%s", dot_suffix);
  g_autoptr(FlBasicMessageChannel) set_image_file_format_channel = fl_basic_message_channel_new(messenger, set_image_file_format_channel_name, FL_MESSAGE_CODEC(codec));
  fl_basic_message_channel_set_message_handler(set_image_file_format_channel, nullptr, nullptr, nullptr);
}

void camera_linux_camera_api_respond_get_available_cameras(CameraLinuxCameraApiResponseHandle* response_handle, FlValue* return_value) {
  g_autoptr(CameraLinuxCameraApiGetAvailableCamerasResponse) response = camera_linux_camera_api_get_available_cameras_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getAvailableCameras", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_available_cameras(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetAvailableCamerasResponse) response = camera_linux_camera_api_get_available_cameras_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getAvailableCameras", error->message);
  }
}

void camera_linux_camera_api_respond_create(CameraLinuxCameraApiResponseHandle* response_handle, int64_t return_value) {
  g_autoptr(CameraLinuxCameraApiCreateResponse) response = camera_linux_camera_api_create_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "create", error->message);
  }
}

void camera_linux_camera_api_respond_error_create(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiCreateResponse) response = camera_linux_camera_api_create_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "create", error->message);
  }
}

void camera_linux_camera_api_respond_initialize(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiInitializeResponse) response = camera_linux_camera_api_initialize_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "initialize", error->message);
  }
}

void camera_linux_camera_api_respond_error_initialize(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiInitializeResponse) response = camera_linux_camera_api_initialize_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "initialize", error->message);
  }
}

void camera_linux_camera_api_respond_start_image_stream(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiStartImageStreamResponse) response = camera_linux_camera_api_start_image_stream_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startImageStream", error->message);
  }
}

void camera_linux_camera_api_respond_error_start_image_stream(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStartImageStreamResponse) response = camera_linux_camera_api_start_image_stream_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startImageStream", error->message);
  }
}

void camera_linux_camera_api_respond_stop_image_stream(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiStopImageStreamResponse) response = camera_linux_camera_api_stop_image_stream_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopImageStream", error->message);
  }
}

void camera_linux_camera_api_respond_error_stop_image_stream(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStopImageStreamResponse) response = camera_linux_camera_api_stop_image_stream_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopImageStream", error->message);
  }
}

void camera_linux_camera_api_respond_received_image_stream_data(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiReceivedImageStreamDataResponse) response = camera_linux_camera_api_received_image_stream_data_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "receivedImageStreamData", error->message);
  }
}

void camera_linux_camera_api_respond_error_received_image_stream_data(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiReceivedImageStreamDataResponse) response = camera_linux_camera_api_received_image_stream_data_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "receivedImageStreamData", error->message);
  }
}

void camera_linux_camera_api_respond_dispose(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiDisposeResponse) response = camera_linux_camera_api_dispose_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "dispose", error->message);
  }
}

void camera_linux_camera_api_respond_error_dispose(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiDisposeResponse) response = camera_linux_camera_api_dispose_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "dispose", error->message);
  }
}

void camera_linux_camera_api_respond_lock_capture_orientation(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiLockCaptureOrientationResponse) response = camera_linux_camera_api_lock_capture_orientation_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "lockCaptureOrientation", error->message);
  }
}

void camera_linux_camera_api_respond_error_lock_capture_orientation(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiLockCaptureOrientationResponse) response = camera_linux_camera_api_lock_capture_orientation_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "lockCaptureOrientation", error->message);
  }
}

void camera_linux_camera_api_respond_unlock_capture_orientation(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiUnlockCaptureOrientationResponse) response = camera_linux_camera_api_unlock_capture_orientation_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "unlockCaptureOrientation", error->message);
  }
}

void camera_linux_camera_api_respond_error_unlock_capture_orientation(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiUnlockCaptureOrientationResponse) response = camera_linux_camera_api_unlock_capture_orientation_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "unlockCaptureOrientation", error->message);
  }
}

void camera_linux_camera_api_respond_take_picture(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* return_value) {
  g_autoptr(CameraLinuxCameraApiTakePictureResponse) response = camera_linux_camera_api_take_picture_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "takePicture", error->message);
  }
}

void camera_linux_camera_api_respond_error_take_picture(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiTakePictureResponse) response = camera_linux_camera_api_take_picture_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "takePicture", error->message);
  }
}

void camera_linux_camera_api_respond_prepare_for_video_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiPrepareForVideoRecordingResponse) response = camera_linux_camera_api_prepare_for_video_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "prepareForVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_prepare_for_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiPrepareForVideoRecordingResponse) response = camera_linux_camera_api_prepare_for_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "prepareForVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_start_video_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiStartVideoRecordingResponse) response = camera_linux_camera_api_start_video_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_start_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStartVideoRecordingResponse) response = camera_linux_camera_api_start_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "startVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_stop_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* return_value) {
  g_autoptr(CameraLinuxCameraApiStopVideoRecordingResponse) response = camera_linux_camera_api_stop_video_recording_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_stop_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiStopVideoRecordingResponse) response = camera_linux_camera_api_stop_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "stopVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_pause_video_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiPauseVideoRecordingResponse) response = camera_linux_camera_api_pause_video_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "pauseVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_pause_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiPauseVideoRecordingResponse) response = camera_linux_camera_api_pause_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "pauseVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_resume_video_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiResumeVideoRecordingResponse) response = camera_linux_camera_api_resume_video_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "resumeVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_resume_video_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiResumeVideoRecordingResponse) response = camera_linux_camera_api_resume_video_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "resumeVideoRecording", error->message);
  }
}

void camera_linux_camera_api_respond_set_flash_mode(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetFlashModeResponse) response = camera_linux_camera_api_set_flash_mode_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFlashMode", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_flash_mode(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetFlashModeResponse) response = camera_linux_camera_api_set_flash_mode_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFlashMode", error->message);
  }
}

void camera_linux_camera_api_respond_set_exposure_mode(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetExposureModeResponse) response = camera_linux_camera_api_set_exposure_mode_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureMode", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_exposure_mode(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetExposureModeResponse) response = camera_linux_camera_api_set_exposure_mode_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureMode", error->message);
  }
}

void camera_linux_camera_api_respond_set_exposure_point(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetExposurePointResponse) response = camera_linux_camera_api_set_exposure_point_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposurePoint", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_exposure_point(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetExposurePointResponse) response = camera_linux_camera_api_set_exposure_point_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposurePoint", error->message);
  }
}

void camera_linux_camera_api_respond_set_lens_position(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetLensPositionResponse) response = camera_linux_camera_api_set_lens_position_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setLensPosition", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_lens_position(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetLensPositionResponse) response = camera_linux_camera_api_set_lens_position_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setLensPosition", error->message);
  }
}

void camera_linux_camera_api_respond_get_min_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle, double return_value) {
  g_autoptr(CameraLinuxCameraApiGetMinExposureOffsetResponse) response = camera_linux_camera_api_get_min_exposure_offset_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMinExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_min_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetMinExposureOffsetResponse) response = camera_linux_camera_api_get_min_exposure_offset_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMinExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_get_max_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle, double return_value) {
  g_autoptr(CameraLinuxCameraApiGetMaxExposureOffsetResponse) response = camera_linux_camera_api_get_max_exposure_offset_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMaxExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_max_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetMaxExposureOffsetResponse) response = camera_linux_camera_api_get_max_exposure_offset_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMaxExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_set_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetExposureOffsetResponse) response = camera_linux_camera_api_set_exposure_offset_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_exposure_offset(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetExposureOffsetResponse) response = camera_linux_camera_api_set_exposure_offset_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setExposureOffset", error->message);
  }
}

void camera_linux_camera_api_respond_set_focus_mode(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetFocusModeResponse) response = camera_linux_camera_api_set_focus_mode_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusMode", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_focus_mode(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetFocusModeResponse) response = camera_linux_camera_api_set_focus_mode_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusMode", error->message);
  }
}

void camera_linux_camera_api_respond_set_focus_point(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetFocusPointResponse) response = camera_linux_camera_api_set_focus_point_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusPoint", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_focus_point(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetFocusPointResponse) response = camera_linux_camera_api_set_focus_point_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setFocusPoint", error->message);
  }
}

void camera_linux_camera_api_respond_get_min_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle, double return_value) {
  g_autoptr(CameraLinuxCameraApiGetMinZoomLevelResponse) response = camera_linux_camera_api_get_min_zoom_level_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMinZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_min_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetMinZoomLevelResponse) response = camera_linux_camera_api_get_min_zoom_level_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMinZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_get_max_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle, double return_value) {
  g_autoptr(CameraLinuxCameraApiGetMaxZoomLevelResponse) response = camera_linux_camera_api_get_max_zoom_level_response_new(return_value);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMaxZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_error_get_max_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiGetMaxZoomLevelResponse) response = camera_linux_camera_api_get_max_zoom_level_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "getMaxZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_set_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetZoomLevelResponse) response = camera_linux_camera_api_set_zoom_level_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_zoom_level(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetZoomLevelResponse) response = camera_linux_camera_api_set_zoom_level_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setZoomLevel", error->message);
  }
}

void camera_linux_camera_api_respond_pause_preview(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiPausePreviewResponse) response = camera_linux_camera_api_pause_preview_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "pausePreview", error->message);
  }
}

void camera_linux_camera_api_respond_error_pause_preview(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiPausePreviewResponse) response = camera_linux_camera_api_pause_preview_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "pausePreview", error->message);
  }
}

void camera_linux_camera_api_respond_resume_preview(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiResumePreviewResponse) response = camera_linux_camera_api_resume_preview_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "resumePreview", error->message);
  }
}

void camera_linux_camera_api_respond_error_resume_preview(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiResumePreviewResponse) response = camera_linux_camera_api_resume_preview_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "resumePreview", error->message);
  }
}

void camera_linux_camera_api_respond_update_description_while_recording(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse) response = camera_linux_camera_api_update_description_while_recording_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "updateDescriptionWhileRecording", error->message);
  }
}

void camera_linux_camera_api_respond_error_update_description_while_recording(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiUpdateDescriptionWhileRecordingResponse) response = camera_linux_camera_api_update_description_while_recording_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "updateDescriptionWhileRecording", error->message);
  }
}

void camera_linux_camera_api_respond_set_image_file_format(CameraLinuxCameraApiResponseHandle* response_handle) {
  g_autoptr(CameraLinuxCameraApiSetImageFileFormatResponse) response = camera_linux_camera_api_set_image_file_format_response_new();
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setImageFileFormat", error->message);
  }
}

void camera_linux_camera_api_respond_error_set_image_file_format(CameraLinuxCameraApiResponseHandle* response_handle, const gchar* code, const gchar* message, FlValue* details) {
  g_autoptr(CameraLinuxCameraApiSetImageFileFormatResponse) response = camera_linux_camera_api_set_image_file_format_response_new_error(code, message, details);
  g_autoptr(GError) error = nullptr;
  if (!fl_basic_message_channel_respond(response_handle->channel, response_handle->response_handle, response->value, &error)) {
    g_warning("Failed to send response to %s.%s: %s", "CameraApi", "setImageFileFormat", error->message);
  }
}

struct _CameraLinuxCameraGlobalEventApi {
  GObject parent_instance;

  FlBinaryMessenger* messenger;
  gchar *suffix;
};

G_DEFINE_TYPE(CameraLinuxCameraGlobalEventApi, camera_linux_camera_global_event_api, G_TYPE_OBJECT)

static void camera_linux_camera_global_event_api_dispose(GObject* object) {
  CameraLinuxCameraGlobalEventApi* self = CAMERA_LINUX_CAMERA_GLOBAL_EVENT_API(object);
  g_clear_object(&self->messenger);
  g_clear_pointer(&self->suffix, g_free);
  G_OBJECT_CLASS(camera_linux_camera_global_event_api_parent_class)->dispose(object);
}

static void camera_linux_camera_global_event_api_init(CameraLinuxCameraGlobalEventApi* self) {
}

static void camera_linux_camera_global_event_api_class_init(CameraLinuxCameraGlobalEventApiClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_global_event_api_dispose;
}

CameraLinuxCameraGlobalEventApi* camera_linux_camera_global_event_api_new(FlBinaryMessenger* messenger, const gchar* suffix) {
  CameraLinuxCameraGlobalEventApi* self = CAMERA_LINUX_CAMERA_GLOBAL_EVENT_API(g_object_new(camera_linux_camera_global_event_api_get_type(), nullptr));
  self->messenger = FL_BINARY_MESSENGER(g_object_ref(messenger));
  self->suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  return self;
}

struct _CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse, camera_linux_camera_global_event_api_device_orientation_changed_response, G_TYPE_OBJECT)

static void camera_linux_camera_global_event_api_device_orientation_changed_response_dispose(GObject* object) {
  CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self = CAMERA_LINUX_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_global_event_api_device_orientation_changed_response_parent_class)->dispose(object);
}

static void camera_linux_camera_global_event_api_device_orientation_changed_response_init(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self) {
}

static void camera_linux_camera_global_event_api_device_orientation_changed_response_class_init(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_global_event_api_device_orientation_changed_response_dispose;
}

static CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* camera_linux_camera_global_event_api_device_orientation_changed_response_new(FlValue* response) {
  CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self = CAMERA_LINUX_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(g_object_new(camera_linux_camera_global_event_api_device_orientation_changed_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_global_event_api_device_orientation_changed_response_is_error(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_global_event_api_device_orientation_changed_response_get_error_code(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_global_event_api_device_orientation_changed_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_global_event_api_device_orientation_changed_response_get_error_message(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_global_event_api_device_orientation_changed_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_global_event_api_device_orientation_changed_response_get_error_details(CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_GLOBAL_EVENT_API_DEVICE_ORIENTATION_CHANGED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_global_event_api_device_orientation_changed_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_global_event_api_device_orientation_changed_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_global_event_api_device_orientation_changed(CameraLinuxCameraGlobalEventApi* self, CameraLinuxPlatformDeviceOrientation orientation, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_custom(130, fl_value_new_int(orientation), (GDestroyNotify)fl_value_unref));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraGlobalEventApi.deviceOrientationChanged%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_global_event_api_device_orientation_changed_cb, task);
}

CameraLinuxCameraGlobalEventApiDeviceOrientationChangedResponse* camera_linux_camera_global_event_api_device_orientation_changed_finish(CameraLinuxCameraGlobalEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_global_event_api_device_orientation_changed_response_new(response);
}

struct _CameraLinuxCameraEventApi {
  GObject parent_instance;

  FlBinaryMessenger* messenger;
  gchar *suffix;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApi, camera_linux_camera_event_api, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_dispose(GObject* object) {
  CameraLinuxCameraEventApi* self = CAMERA_LINUX_CAMERA_EVENT_API(object);
  g_clear_object(&self->messenger);
  g_clear_pointer(&self->suffix, g_free);
  G_OBJECT_CLASS(camera_linux_camera_event_api_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_init(CameraLinuxCameraEventApi* self) {
}

static void camera_linux_camera_event_api_class_init(CameraLinuxCameraEventApiClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_dispose;
}

CameraLinuxCameraEventApi* camera_linux_camera_event_api_new(FlBinaryMessenger* messenger, const gchar* suffix) {
  CameraLinuxCameraEventApi* self = CAMERA_LINUX_CAMERA_EVENT_API(g_object_new(camera_linux_camera_event_api_get_type(), nullptr));
  self->messenger = FL_BINARY_MESSENGER(g_object_ref(messenger));
  self->suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  return self;
}

struct _CameraLinuxCameraEventApiInitializedResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApiInitializedResponse, camera_linux_camera_event_api_initialized_response, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_initialized_response_dispose(GObject* object) {
  CameraLinuxCameraEventApiInitializedResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_INITIALIZED_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_event_api_initialized_response_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_initialized_response_init(CameraLinuxCameraEventApiInitializedResponse* self) {
}

static void camera_linux_camera_event_api_initialized_response_class_init(CameraLinuxCameraEventApiInitializedResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_initialized_response_dispose;
}

static CameraLinuxCameraEventApiInitializedResponse* camera_linux_camera_event_api_initialized_response_new(FlValue* response) {
  CameraLinuxCameraEventApiInitializedResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_INITIALIZED_RESPONSE(g_object_new(camera_linux_camera_event_api_initialized_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_event_api_initialized_response_is_error(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_event_api_initialized_response_get_error_code(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_event_api_initialized_response_get_error_message(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_event_api_initialized_response_get_error_details(CameraLinuxCameraEventApiInitializedResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_INITIALIZED_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_initialized_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_event_api_initialized_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_event_api_initialized(CameraLinuxCameraEventApi* self, CameraLinuxPlatformCameraState* initial_state, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_custom_object(139, G_OBJECT(initial_state)));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraEventApi.initialized%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_event_api_initialized_cb, task);
}

CameraLinuxCameraEventApiInitializedResponse* camera_linux_camera_event_api_initialized_finish(CameraLinuxCameraEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_event_api_initialized_response_new(response);
}

struct _CameraLinuxCameraEventApiErrorResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(CameraLinuxCameraEventApiErrorResponse, camera_linux_camera_event_api_error_response, G_TYPE_OBJECT)

static void camera_linux_camera_event_api_error_response_dispose(GObject* object) {
  CameraLinuxCameraEventApiErrorResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_ERROR_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(camera_linux_camera_event_api_error_response_parent_class)->dispose(object);
}

static void camera_linux_camera_event_api_error_response_init(CameraLinuxCameraEventApiErrorResponse* self) {
}

static void camera_linux_camera_event_api_error_response_class_init(CameraLinuxCameraEventApiErrorResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = camera_linux_camera_event_api_error_response_dispose;
}

static CameraLinuxCameraEventApiErrorResponse* camera_linux_camera_event_api_error_response_new(FlValue* response) {
  CameraLinuxCameraEventApiErrorResponse* self = CAMERA_LINUX_CAMERA_EVENT_API_ERROR_RESPONSE(g_object_new(camera_linux_camera_event_api_error_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean camera_linux_camera_event_api_error_response_is_error(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* camera_linux_camera_event_api_error_response_get_error_code(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* camera_linux_camera_event_api_error_response_get_error_message(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* camera_linux_camera_event_api_error_response_get_error_details(CameraLinuxCameraEventApiErrorResponse* self) {
  g_return_val_if_fail(CAMERA_LINUX_IS_CAMERA_EVENT_API_ERROR_RESPONSE(self), nullptr);
  g_assert(camera_linux_camera_event_api_error_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void camera_linux_camera_event_api_error_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void camera_linux_camera_event_api_error(CameraLinuxCameraEventApi* self, const gchar* message, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  fl_value_append_take(args, fl_value_new_string(message));
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.camera_linux.CameraEventApi.error%s", self->suffix);
  g_autoptr(CameraLinuxMessageCodec) codec = camera_linux_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, camera_linux_camera_event_api_error_cb, task);
}

CameraLinuxCameraEventApiErrorResponse* camera_linux_camera_event_api_error_finish(CameraLinuxCameraEventApi* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return camera_linux_camera_event_api_error_response_new(response);
}
